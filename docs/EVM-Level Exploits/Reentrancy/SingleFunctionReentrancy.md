# 单函数重入攻击 - 学习指南

## 快速开始

```bash
# 1. 运行测试
forge test --match-contract ReentrancyTest -vvvv

# 2. 只运行攻击演示
forge test --match-test testReentrancyAttack -vvvv

# 3. 查看攻击机制详解
forge test --match-test testReentrancyMechanism -vvvv
```

## 文件结构

```
SingleFunctionReentrancy.sol
├── VulnerableBank          # 漏洞合约
├── ReentrancyAttacker      # 攻击合约
├── ReentrancyTest          # Foundry测试
├── SecureBank              # 修复版本1（CEI模式）
└── SecureBankWithGuard     # 修复版本2（ReentrancyGuard）
```

## 攻击流程详解

### 初始状态
```
Bank总余额: 10 ETH (victim1: 5 ETH, victim2: 5 ETH)
攻击者存入: 1 ETH
Bank总余额: 11 ETH
```

### 攻击过程

**第1次调用 withdraw(1 ETH):**
```
1. require(balances[attacker] >= 1 ETH) 通过（余额=1）
2. 发送1 ETH给attacker → 触发attacker.receive()
   [此时 balances[attacker] = 1 ETH，还未更新！]
```

**在 receive() 中第2次调用 withdraw(1 ETH):**
```
3. require(balances[attacker] >= 1 ETH) 仍然通过
4. 再发送1 ETH → 再次触发receive()
   [balances[attacker] 仍然 = 1 ETH]
```

**继续重入...**
```
第3次、第4次、第5次... 直到：
- Bank余额不足 或
- 达到攻击次数上限 或  
- Gas耗尽
```

**最终状态更新:**
```
所有重入完成后，才执行：
balances[attacker] -= 1 ETH
但此时攻击者已经拿走了 5 ETH！
```

## 关键代码分析

### 漏洞点
```solidity
function withdraw(uint256 _amount) external {
    require(balances[msg.sender] >= _amount, "Insufficient balance");
    
    // ❌ 先外部调用
    (bool success, ) = msg.sender.call{value: _amount}("");
    require(success, "Transfer failed");
    
    // ❌ 后更新状态（太晚了！）
    balances[msg.sender] -= _amount;
}
```

### 攻击触发点
```solidity
receive() external payable {
    attackCount++;
    
    // 只要余额记录还未更新，就继续重入
    if (attackCount < maxAttacks && bank.getBalance() >= attackAmount) {
        bank.withdraw(attackAmount);  // 重入！
    }
}
```

## 修复方案对比

### 方案1: CEI模式（推荐）
```solidity
function withdraw(uint256 _amount) external {
    require(balances[msg.sender] >= _amount);
    
    // ✅ 先更新状态
    balances[msg.sender] -= _amount;
    
    // ✅ 后外部调用
    (bool success, ) = msg.sender.call{value: _amount}("");
    require(success);
}
```

**优点:**
- 简单直接
- Gas高效
- 符合最佳实践

**原理:** 当重入时，balances已经减少，require检查会失败

### 方案2: ReentrancyGuard
```solidity
function withdraw(uint256 _amount) external nonReentrant {
    require(balances[msg.sender] >= _amount);
    
    (bool success, ) = msg.sender.call{value: _amount}("");
    require(success);
    
    balances[msg.sender] -= _amount;
}
```

**优点:**
- 适用于复杂逻辑
- 清晰标识保护点

**缺点:**
- 额外gas消耗（~2300 gas）
- 需要导入库

## 实战审计技巧

### 快速识别重入风险

1. **搜索外部调用关键字:**
```solidity
// 高风险操作
.call{value: x}()
.transfer()
.send()
address.call()
externalContract.method()
```

2. **检查状态更新顺序:**
```
外部调用前是否已经更新所有相关状态？
- 余额
- 权限
- 状态标志
```

3. **检查回调可能:**
```solidity
// 可能触发回调的情况
- ERC777 tokensReceived hook
- ERC721 onERC721Received
- ERC1155 onERC1155Received  
- Fallback/Receive 函数
```

### 审计Checklist

- [ ] 是否使用 CEI 模式？
- [ ] 外部调用前状态是否完全更新？
- [ ] 是否有 ReentrancyGuard 保护？
- [ ] 多个函数间是否存在跨函数重入风险？
- [ ] 是否依赖合约余额进行计算？
- [ ] ERC777/ERC721 等带回调的代币是否安全？

## 变体学习路径

掌握单函数重入后，继续学习：

1. **Cross-function reentrancy** (跨函数重入)
   - 在A函数中调用，重入到B函数
   - 共享状态导致的漏洞

2. **Read-only reentrancy** (只读重入)
   - 利用view函数读取不一致状态
   - Curve vyper漏洞就是这种类型

3. **Cross-contract reentrancy** (跨合约重入)
   - 通过中间合约进行重入
   - 更隐蔽，难以检测

## 真实案例分析

### The DAO (2016)
- 损失: ~$60M
- 原理: 完全相同的单函数重入
- 影响: 导致ETH硬分叉

### Lendf.me (2020)
- 损失: $25M
- 原理: ERC777 token的重入
- 教训: 注意带回调的token标准

### Curve vyper (2023.07)
- 损失: $73M+
- 原理: Read-only reentrancy
- 特点: 编译器bug导致的重入保护失效

## 实践建议

1. **运行测试并观察日志**
   - 看每次重入时的状态变化
   - 理解为什么余额检查会重复通过

2. **修改攻击参数**
   - 改变 `maxAttacks` 看效果
   - 调整初始存款金额

3. **尝试绕过修复版本**
   - 攻击 SecureBank 会失败
   - 理解为什么CEI模式有效

4. **编写invariant tests**
   - 用AST工具分析状态变化
   - 建立不变量: `withdrawn <= deposited`

