# Read-Only Reentrancy



## 快速开始

```bash
# 1. 经典AMM场景（最重要）
forge test --match-test testReadOnlyReentrancy -vvvv

# 2. 理解攻击机制
forge test --match-test testExplainAttack -vvvv

# 3. Curve虚拟价格场景
forge test --match-test testCurveVirtualPrice -vvvv

# 4. Balancer BPT汇率场景
forge test --match-test testBalancerGetRate -vvvv
```

## 核心概念

### 与传统重入的根本区别

```
传统重入（修改状态）:
User → withdraw()
    → transfer() 
    → User.receive()
    → withdraw() again ✗ 修改同一状态

Read-Only重入（读取不一致状态）:
User → removeLiquidity()
    → transfer()
    → User.receive()
    → otherProtocol.borrow() ✗ 读取虚假状态
        → amm.getLPValue() ← 返回错误值！
```

### 关键：View函数不安全！

```solidity
// 大家都认为view函数是"安全"的
function getLPValue(uint shares) external view returns (uint256) {
    // 不修改状态
    // nonReentrant不能加在view上
    // 但可以在不一致状态下被调用！
    return (shares * reserves) / totalSupply;
}
```

**问题：**
- `reserves` 和 `totalSupply` 不是同时更新的
- 在转账回调窗口，它们不匹配
- 导致计算结果虚高或虚低

## 三大经典场景

### 场景1: AMM储备量不一致（最常见）

**正常流程：**
```
reserves = 100 ETH
totalSupply = 100 LP
每个LP价值 = 100/100 = 1 ETH
```

**攻击流程：**

```solidity
function removeLiquidity(uint shares) external {
    uint amount = (shares * reserves) / totalSupply;
    
    balanceOf[msg.sender] -= shares;
    totalSupply -= shares;  // ← 第1步：totalSupply变成90
    
    msg.sender.call{value: amount}("");  // ← 第2步：触发回调
    
    // 漏洞窗口在这里
    // totalSupply = 90 (已更新)
    // reserves = 100 (未更新)
    // LP价值 = 100/90 = 1.11 ETH (虚高11%！)
    
    reserves -= amount;  // ← 第3步：最后才更新reserves
}
```

**攻击者在回调中：**
```solidity
receive() external payable {
    // 此时getLPValue()会返回虚高值
    uint256 fakeValue = amm.getLPValue(myShares);
    // fakeValue = myShares * 100 / 90 = 虚高11%
    
    // 用虚假的高价值借款
    lending.borrow(moreThanAllowed);
}
```

**结果：**
```
攻击者借到的钱 = 正常额度 × 1.11
超额借款 = 11%
如果有100个LP，可以多借11 ETH
```

### 场景2: Curve虚拟价格（Curve vyper漏洞）

**什么是虚拟价格？**
```python
# Curve中的概念
virtual_price = totalAssets / totalSupply

# 用途：
# - 其他协议用来估算LP代币价值
# - Alchemix, JPEGd等都依赖这个
```

**vyper编译器bug：**
```vyper
# Curve的代码（vyper）
@external
@nonreentrant('lock')
def remove_liquidity(...):
    self._burn(shares)          # totalSupply减少
    self._transfer_out(tokens)  # 可能触发回调（vyper bug）
    self.balances -= tokens     # 最后更新
```

**问题：**
- vyper 0.2.15-0.3.0的编译器bug
- `@nonreentrant` 装饰器没有正确编译
- 允许在状态不一致时重入

**攻击流程（2023.07实际攻击）：**

```
1. 攻击者在Curve池子有LP
   ↓
2. 调用remove_liquidity_one_coin()
   ├─ _burn(shares)           totalSupply = 90
   ├─ raw_call(transfer)      ← 触发回调
   │   │
   │   └─ 攻击者重入到Alchemix
   │       └─ Alchemix.borrow()
   │           └─ curve.get_virtual_price()
   │               ├─ totalSupply = 90 (已减少)
   │               ├─ totalAssets = 100 (还未减少)
   │               └─ 返回 100/90 = 1.11x (虚高！)
   │
   └─ 更新totalAssets = 90
   
3. Alchemix认为LP价值高
   ↓
4. 允许超额借款
   ↓
5. 攻击者获利，Alchemix坏账
```

**实际损失：**
```
Alchemix: $13.6M
JPEGd: $11.5M
Metronome: $1.6M
其他协议: $40M+
总计: $73M+
```

**为什么损失这么大？**
- 多个协议共享同一个Curve池
- 一个池被攻击，所有依赖方受损
- 级联效应导致系统性风险

### 场景3: Balancer BPT汇率

**Balancer的机制：**
```solidity
// BPT (Balancer Pool Token) 的汇率
function getRate() external view returns (uint256) {
    uint256 totalValue = calculatePoolValue();
    return (totalValue * 1e18) / totalSupply;
}

// 其他协议用这个估算BPT价值
function borrow() external {
    uint256 bptValue = balancer.getRate() * userBPT / 1e18;
    uint256 maxBorrow = bptValue * collateralRatio;
    // ...
}
```

**攻击窗口：**
```solidity
function exitPool(uint256 bptAmount) external {
    _burn(bptAmount);           // ← totalSupply减少
    
    _transferTokens(tokens);    // ← 可能触发回调
    
    // 漏洞窗口
    // totalSupply已减少
    // 但pool balances还未减少
    // getRate()返回虚高值
    
    _updateBalances(tokens);    // ← 最后更新
}
```

**与你研究的精度攻击结合：**

```
阶段1: 精度攻击制造不平衡
  ├─ 通过舍入误差操纵池子状态
  ├─ 某些代币余额虚高
  └─ 某些代币余额虚低

阶段2: Read-only重入放大效果
  ├─ 在exitPool回调中
  ├─ getRate()读取不平衡+不一致状态
  ├─ 返回极度虚高的BPT价值
  └─ 其他协议基于此超额借款

阶段3: 提取利润
  ├─ 攻击者借到远超抵押品的资金
  ├─ 还闪电贷
  └─ 获利离场
```

## 真实案例深度分析

### Curve vyper漏洞 (2023.07.30)

**漏洞时间线：**

```
2023.07.30 02:00 UTC
├─ 攻击者发现vyper编译器bug
├─ 影响vyper 0.2.15, 0.2.16, 0.3.0
└─ 所有使用这些版本的Curve池子受影响

主要被攻击的池子：
├─ CRV/ETH pool
├─ alETH/ETH pool  
├─ msETH/ETH pool
└─ pETH/ETH pool

受影响的协议（依赖这些池子）：
├─ Alchemix - $13.6M
├─ JPEGd - $11.5M
├─ Metronome - $1.6M
└─ 其他 - $40M+
```

**技术细节：**

```python
# Curve的代码（简化）
@external
@nonreentrant('lock')
def remove_liquidity_one_coin(
    _token_amount: uint256,
    i: int128,
    _min_amount: uint256
) -> uint256:
    # 计算能取回多少代币
    dy: uint256 = self._calc_withdraw_one_coin(_token_amount, i)
    
    # Bug: 这里应该有重入保护，但vyper编译错误
    self.balanceOf[msg.sender] -= _token_amount
    self.totalSupply -= _token_amount
    
    # 转账（触发回调）
    response: Bytes[32] = raw_call(
        self.coins[i],
        _abi_encode(msg.sender, dy, method_id=method_id("transfer(address,uint256)")),
        max_outsize=32,
    )
    
    # 此时如果重入get_virtual_price()
    # totalSupply已经减少了
    # 但self.balances[i]还没减少
    # 导致virtual_price = totalValue / totalSupply 虚高
    
    self.balances[i] -= dy  # 最后才更新
```

**攻击者的操作：**

```solidity
// 攻击合约
contract CurveExploit {
    CurvePool pool;
    Alchemix alchemix;
    
    function attack() external {
        // 1. 获得大量Curve LP
        pool.add_liquidity([100e18, 100e18], 0);
        
        // 2. 移除流动性，触发重入
        pool.remove_liquidity_one_coin(lpAmount, 0, 0);
    }
    
    // 在转账回调中
    fallback() external payable {
        // 3. 重入到Alchemix
        // Alchemix会调用pool.get_virtual_price()
        // 得到虚高的价格
        
        alchemix.depositCollateral(lpAmount);
        alchemix.borrow(tooMuch);  // 基于虚假的高价值
    }
}
```

**为什么防御失败？**

1. **编译器bug**
   - vyper的`@nonreentrant`没有正确编译
   - 重入保护形同虚设

2. **信任假设**
   - Alchemix等协议信任Curve的view函数
   - 没有额外验证

3. **系统性风险**
   - 多个协议共用一个价格源
   - 一个出问题，全部受影响

**修复方法：**

```python
# 修复后的vyper代码
@external
@nonreentrant('lock')
def remove_liquidity_one_coin(...):
    # 1. 先更新所有状态
    self.balanceOf[msg.sender] -= _token_amount
    self.totalSupply -= _token_amount
    self.balances[i] -= dy  # ← 移到这里
    
    # 2. 最后再转账
    raw_call(self.coins[i], ...)
    
# 并且升级vyper编译器
```

**调用方的修复：**

```solidity
// Alchemix等协议的修复
function borrow() external {
    // 检查Curve池子是否在重入状态
    require(!curve.isInReentrantState(), "Curve in reentrancy");
    
    uint256 price = curve.get_virtual_price();
    // ...
}
```

## 防御策略

### 方案1: 检查重入状态（最推荐）

```solidity
contract SecureAMM {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    uint256 private _status = NOT_ENTERED;
    
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    uint256 public reserves;
    
    function removeLiquidity(uint shares) external {
        _status = ENTERED;  // ← 标记进入
        
        // 执行逻辑...
        
        _status = NOT_ENTERED;  // ← 退出
    }
    
    // View函数检查重入状态
    function getLPValue(uint shares) external view returns (uint256) {
        require(_status != ENTERED, "Cannot read during reentrancy");
        
        return (shares * reserves) / totalSupply;
    }
}
```

**优点：**
- 简单有效
- 明确阻止在不一致状态读取
- Gas成本低

**缺点：**
- View函数变成了非纯view（检查状态）
- 需要协调所有相关的view函数

### 方案2: 原子更新所有状态

```solidity
contract SafeAMM {
    function removeLiquidity(uint shares) external {
        uint amount = (shares * reserves) / totalSupply;
        
        // 先更新所有状态
        balanceOf[msg.sender] -= shares;
        totalSupply -= shares;
        reserves -= amount;  // ← 在外部调用前完成
        
        // 最后才外部调用
        msg.sender.call{value: amount}("");
    }
}
```

**优点：**
- 完全消除不一致窗口
- 符合CEI模式最佳实践

**缺点：**
- 可能需要重构代码逻辑
- 某些情况下难以实现（如需要计算返回值）

### 方案3: 快照机制

```solidity
contract SnapshotAMM {
    struct Snapshot {
        uint256 reserves;
        uint256 totalSupply;
        uint256 blockNumber;
    }
    
    Snapshot public lastSnapshot;
    
    function _updateSnapshot() internal {
        lastSnapshot = Snapshot({
            reserves: reserves,
            totalSupply: totalSupply,
            blockNumber: block.number
        });
    }
    
    // 使用上一个区块的快照
    function getLPValue(uint shares) external view returns (uint256) {
        // 如果是当前区块，可能有重入风险
        if (block.number == lastSnapshot.blockNumber) {
            // 使用上一次的快照
            return (shares * lastSnapshot.reserves) / lastSnapshot.totalSupply;
        }
        
        // 否则使用当前值
        return (shares * reserves) / totalSupply;
    }
}
```

**优点：**
- 防止同区块内的攻击
- 不影响正常操作

**缺点：**
- 需要额外存储
- 可能有延迟（使用旧数据）

### 方案4: 调用方保护

```solidity
// 依赖方协议的防御
contract SafeLending {
    function borrow() external {
        // 多重验证
        uint256 lpValue1 = amm.getLPValue(shares);
        
        // 检查AMM是否在一致状态
        (uint256 r0, uint256 r1) = amm.getReserves();
        uint256 ts = amm.totalSupply();
        uint256 lpValue2 = (shares * (r0 + r1)) / ts;
        
        // 两个值应该接近
        require(
            abs(lpValue1 - lpValue2) < lpValue1 / 100,
            "Inconsistent state detected"
        );
        
        // ...
    }
}
```

## 审计检查清单

### 识别风险函数

**第一步：找出所有"移除流动性"类函数**

```bash
# 搜索关键词
grep -rn "remove\|exit\|withdraw\|burn" contracts/

# 特别关注
- removeLiquidity
- exitPool  
- withdraw
- redeem
- _burn
```

**第二步：检查状态更新顺序**

```solidity
// 危险模式
function removeLiquidity() {
    totalSupply -= shares;     // 更新1
    transfer(user, tokens);    // 外部调用（触发回调）
    reserves -= tokens;        // 更新2 ← 太晚了！
}

// 安全模式
function removeLiquidity() {
    totalSupply -= shares;     // 更新1
    reserves -= tokens;        // 更新2 ← 在外部调用前
    transfer(user, tokens);    // 外部调用
}
```

**第三步：识别依赖的view函数**

```solidity
// 问自己：
// 1. 哪些view函数会被其他协议调用？
// 2. 它们依赖哪些状态变量？
// 3. 这些变量何时更新？

// 高风险view函数：
function getLPValue() external view returns (uint256) {
    // 依赖: reserves, totalSupply
    return (shares * reserves) / totalSupply;
}

function get_virtual_price() external view returns (uint256) {
    // 依赖: totalAssets, totalSupply
    return totalAssets * 1e18 / totalSupply;
}

function getRate() external view returns (uint256) {
    // 依赖: balances, totalSupply
    return calculateValue(balances) * 1e18 / totalSupply;
}
```

### 完整审计流程

```markdown
## Read-Only Reentrancy 审计检查表

### 第1步：识别外部调用
- [ ] 列出所有external call
- [ ] 标记可能触发回调的操作
- [ ] 特别注意ETH transfer和ERC777

### 第2步：分析状态更新
- [ ] 绘制每个函数的状态更新时间线
- [ ] 标记外部调用的位置
- [ ] 检查是否有状态在外部调用后更新

### 第3步：识别view函数依赖
- [ ] 列出所有public/external view函数
- [ ] 识别它们依赖的状态变量
- [ ] 检查这些变量的更新模式

### 第4步：评估集成风险
- [ ] 你的协议是否被其他协议集成？
- [ ] 其他协议会在什么时候调用你的view函数？
- [ ] 如果在不一致状态下被调用会怎样？

### 第5步：测试攻击场景
- [ ] 编写重入测试
- [ ] 模拟在回调中调用view函数
- [ ] 验证返回值是否异常

### 第6步：建议修复方案
- [ ] 添加重入状态检查
- [ ] 调整状态更新顺序
- [ ] 实现快照机制
- [ ] 添加调用方保护
```

## 使用AST工具检测

### 自动检测模式

```python
# 伪代码：检测read-only reentrancy风险
def detect_readonly_reentrancy(contract_ast):
    risks = []
    
    # 1. 找出所有修改状态的函数
    state_modifying_functions = find_state_modifying_functions(contract_ast)
    
    for func in state_modifying_functions:
        # 2. 分析状态更新时间线
        timeline = analyze_state_timeline(func)
        
        # 3. 检查外部调用位置
        external_calls = find_external_calls(func)
        
        for call in external_calls:
            # 4. 检查是否有状态在调用后更新
            states_after_call = get_states_updated_after(func, call)
            
            if states_after_call:
                # 5. 找出依赖这些状态的view函数
                affected_views = find_views_depending_on(states_after_call)
                
                risks.append({
                    'function': func.name,
                    'external_call': call,
                    'delayed_states': states_after_call,
                    'affected_views': affected_views,
                    'severity': 'HIGH'
                })
    
    return risks

# 生成攻击PoC
def generate_readonly_poc(risk):
    return f"""
    // PoC for {risk.function}
    contract Attacker {{
        receive() external payable {{
            // In callback, call view function
            uint256 fakeValue = target.{risk.affected_views[0]}();
            // Use fake value for profit...
        }}
    }}
    """
```

### 建立不变量测试

```solidity
// 使用Foundry的invariant testing
contract ReadOnlyInvariantTest is Test {
    AMM amm;
    
    function invariant_noInconsistentReads() public {
        // 不变量：任何时候读取都应该一致
        uint256 lpValue1 = amm.getLPValue(100);
        
        (uint256 r, uint256 ts) = (amm.reserves(), amm.totalSupply());
        uint256 lpValue2 = (100 * r) / ts;
        
        // 两种计算方法结果应该相同
        assertApproxEqRel(lpValue1, lpValue2, 0.01e18); // 1%容差
    }
}
```

## 与Balancer研究的连接

### 你的Balancer精度攻击研究

```
当前已知：
├─ 精度损失攻击
│   ├─ 通过舍入误差操纵余额
│   └─ 制造池子不平衡状态

可能的扩展（Read-only reentrancy）：
├─ exitPool时的状态不一致
│   ├─ _burn(bpt)先执行
│   ├─ _transferTokens()触发回调
│   └─ _updateBalances()最后执行
│
├─ getRate()在不一致窗口被调用
│   ├─ totalSupply已减少
│   ├─ balances还未减少
│   └─ 返回虚高的BPT价值
│
└─ 组合攻击
    ├─ 阶段1: 精度攻击制造极端不平衡
    ├─ 阶段2: Read-only重入放大效果
    └─ 阶段3: 其他协议基于虚假价格超额借款
```

### 建议研究方向

1. **审查Balancer的exitPool实现**
   - 状态更新顺序
   - 是否有重入保护
   - getRate()的实现

2. **测试组合攻击**
   - 精度攻击 + Read-only重入
   - 计算放大倍数
   - 评估实际风险

3. **检查集成协议**
   - 哪些协议依赖Balancer的getRate()？
   - Aave, Maker, 其他借贷协议？
   - 它们的防护措施？

