# 跨合约重入攻击 - 高级学习指南

## 快速开始

```bash
# 1. 运行DEX通过Router重入
forge test --match-contract CrossContractReentrancyTest -vvvv

# 2. 运行Oracle重入攻击
forge test --match-contract OracleReentrancyTest -vvvv

# 3. 运行ERC777代币重入
forge test --match-test testTokenReentrancy -vvvv
```

## 核心概念

### 攻击链对比

```
单函数重入:
User → Protocol.withdraw() 
    → ETH transfer 
    → User.receive() 
    → Protocol.withdraw() ✗

跨函数重入:
User → Protocol.withdraw() 
    → ETH transfer 
    → User.receive() 
    → Protocol.transfer() ✗

跨合约重入:
User → ProtocolA.swap() 
    → Router.execute() 
    → User.callback() 
    → ProtocolA.withdraw() ✗✗✗
```

### 为什么最危险？

**1. 信任假设被破坏**
```solidity
// 开发者可能认为：
"Router是我们信任的合约，不会有问题"
"Oracle只是返回数据，很安全"
"这个代币合约是知名项目的"

// 实际上：
// - Router可能被攻击者控制
// - Oracle可能有恶意回调
// - ERC777代币天然带回调
```

**2. 审计盲区**
```
传统审计可能只看：
├─ Protocol内部函数的重入保护
├─ 直接的外部调用
└─ 但忽略了：
    ├─ 中间合约的回调能力
    ├─ 多层调用栈的重入
    └─ "可信"合约的潜在风险
```

**3. 攻击面更广**
```
直接重入: 1个攻击向量
跨函数重入: N个函数组合
跨合约重入: N个函数 × M个外部合约
```

## 三大经典场景

### 场景1: Router/Aggregator重入

**攻击流程:**

```
Step 1: 用户发起swap
┌─────────────────┐
│ DEX.swapToken() │
└────────┬────────┘
         │
         ↓ 调用Router
┌─────────────────────┐
│ Router.executeSwap()│
└────────┬────────────┘
         │
         ↓ 回调用户
┌──────────────────┐
│ Attacker.receive()│ ← tokenBalance还未更新！
└────────┬─────────┘
         │
         ↓ 重入DEX
┌─────────────────┐
│ DEX.withdraw()  │ ← 使用旧的余额！
└─────────────────┘
```

**真实代码示例:**

```solidity
// DEX的漏洞代码
function swapTokenForETH(uint256 _tokenAmount) external {
    require(tokenBalance[msg.sender] >= _tokenAmount);
    
    // 调用Router，Router可能回调用户
    IRouter(router).executeSwap(
        msg.sender,
        address(this),
        _tokenAmount,
        ethAmount
    );
    
    // 状态更新太晚
    tokenBalance[msg.sender] -= _tokenAmount;  // 还没执行
    ethBalance[msg.sender] += ethAmount;       // 还没执行
}

// Router可能的实现
function executeSwap(...) external {
    // 正常Router：只做代币转移
    // 恶意Router：触发用户回调！
    if (user == attacker) {
        ICallback(user).routerCallback();  // 触发攻击
    }
}

// 攻击者的回调
function routerCallback() external {
    // 此时tokenBalance[attacker]还是原值
    dex.withdrawETH(dex.ethBalance(address(this)));  // 重入！
}
```

**防御:**

```solidity
// 修复版本
function swapTokenForETH(uint256 _tokenAmount) external nonReentrant {
    require(tokenBalance[msg.sender] >= _tokenAmount);
    
    // 先更新状态
    tokenBalance[msg.sender] -= _tokenAmount;
    uint256 ethAmount = calculateAmount(_tokenAmount);
    
    // 再调用Router
    IRouter(router).executeSwap(...);
    
    // 最后更新接收的资产
    ethBalance[msg.sender] += ethAmount;
}
```

### 场景2: Price Oracle重入

**为什么Oracle会重入？**

```solidity
// 常见的Oracle调用模式
function borrow(address token, uint256 amount) external {
    // 查询价格 - 外部调用！
    uint256 price = IPriceOracle(oracle).getPrice(token);
    
    // 使用价格计算借款上限
    uint256 maxBorrow = calculateMaxBorrow(price);
    require(amount <= maxBorrow);
    
    // 更新债务
    debt[msg.sender] += amount * price;
    
    // 转账
    token.transfer(msg.sender, amount);
}
```

**问题在哪？**

1. **Oracle可能不是只读的**
```solidity
// 恶意Oracle
function getPrice(address token) external returns (uint256) {
    // 在返回价格前触发回调
    if (msg.sender == targetProtocol) {
        ICallback(attacker).oracleCallback();
    }
    return prices[token];
}
```

2. **时间窗口攻击**
```
getPrice()调用前: collateral = 10 ETH, debt = 0
getPrice()调用中: ← 重入withdrawCollateral()
getPrice()返回后: collateral仍然是10 ETH (记录未更新)
                  但实际已经提走了！
```

**真实案例: Inverse Finance (2022.04) - $15M**

```solidity
// 简化的漏洞代码
function borrow(uint amount) external {
    // 查询价格
    uint price = oracle.getPrice(collateralToken);
    
    // 检查抵押率
    uint maxBorrow = collateral[msg.sender] * price / RATIO;
    require(borrowed[msg.sender] + amount <= maxBorrow);
    
    borrowed[msg.sender] += amount;
    // 转账...
}

// 攻击者在Oracle回调中
function oracleCallback() external {
    // 提取抵押品
    lending.withdrawCollateral(all);
    // 此时borrowed还未更新，但collateral记录仍是旧值
}
```

**防御:**

```solidity
// 方案1: 使用view函数
interface IPriceOracle {
    function getPrice(address token) external view returns (uint256);
    // view确保不会有状态改变，也就不会有回调
}

// 方案2: 先更新状态
function borrow(uint amount) external nonReentrant {
    uint price = oracle.getPrice(token);
    
    // 立即更新债务（在任何可能的重入前）
    borrowed[msg.sender] += amount * price;
    
    // 然后检查（使用更新后的状态）
    uint maxBorrow = collateral[msg.sender] * price / RATIO;
    require(borrowed[msg.sender] <= maxBorrow, "Exceeded limit");
    
    // 最后转账
    token.transfer(msg.sender, amount);
}

// 方案3: 缓存价格
mapping(address => uint256) public cachedPrices;
uint256 public lastUpdate;

function updatePrices() external {
    // 单独的函数更新价格
    cachedPrices[token] = oracle.getPrice(token);
    lastUpdate = block.timestamp;
}

function borrow(uint amount) external {
    // 使用缓存的价格，不调用外部Oracle
    uint price = cachedPrices[token];
    // ...
}
```

### 场景3: ERC777/ERC721代币重入

**ERC777的回调机制:**

```solidity
// ERC777标准
interface IERC777 {
    function send(address to, uint256 amount, bytes calldata data) external;
}

// 接收方必须实现
interface IERC777Recipient {
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}
```

**攻击场景:**

```solidity
// 漏洞Vault
function deposit(address token, uint amount) external {
    // 先转入代币
    IERC777(token).send(address(this), amount, "");
    // 如果是ERC777，会触发 tokensReceived
    
    // 后更新余额
    balances[msg.sender][token] += amount;
}

function withdraw(address token, uint amount) external {
    require(balances[msg.sender][token] >= amount);
    
    // 先转出
    IERC777(token).send(msg.sender, amount, "");
    
    // 后更新
    balances[msg.sender][token] -= amount;
}

// 攻击者实现tokensReceived
function tokensReceived(...) external {
    // 此时balances还未更新
    vault.withdraw(token, vault.balances(address(this), token));
    // ✗ 重复提取！
}
```

**真实案例: Lendf.me (2020.04) - $25M**

```
使用的代币: imBTC (类ERC777)

攻击流程:
1. supply() imBTC
2. withdraw() 触发tokensReceived
3. 在回调中再次supply() 同一批代币
4. 余额被重复计入
5. 利用虚假余额进行借款
```

**防御:**

```solidity
// 方案1: 不支持ERC777
function deposit(address token, uint amount) external {
    // 检查是否是ERC777
    require(!isERC777(token), "ERC777 not supported");
    
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    balances[msg.sender][token] += amount;
}

// 方案2: CEI模式
function withdraw(address token, uint amount) external nonReentrant {
    require(balances[msg.sender][token] >= amount);
    
    // 先更新状态
    balances[msg.sender][token] -= amount;
    
    // 后转账（即使触发回调，余额已经更新了）
    IERC777(token).send(msg.sender, amount, "");
}

// 方案3: 使用安全的ERC20
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

using SafeERC20 for IERC20;

function deposit(address token, uint amount) external {
    // SafeERC20会检查返回值，更安全
    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    balances[msg.sender][token] += amount;
}
```

## 审计实战技巧

### 1. 识别所有外部调用

**使用工具快速扫描:**

```bash
# 查找所有可能触发回调的操作
grep -rn "\.call\|\.delegatecall\|\.transfer\|\.send" contracts/
grep -rn "IERC\|interface" contracts/ | grep "external"

# 查找Oracle调用
grep -rn "oracle\|price\|getPrice" contracts/

# 查找Router/Aggregator
grep -rn "router\|swap\|aggregator" contracts/
```

**建立外部依赖图:**

```
YourProtocol
├─ PriceOracle (external)
│   └─ 可能: ✗ 回调
├─ SwapRouter (external)
│   └─ 可能: ✗ 回调
├─ Token Contracts
│   ├─ ERC20 (标准) → 安全
│   ├─ ERC777 (带回调) → ✗ 危险
│   └─ 自定义Token → 需要审计
└─ Flash Loan Provider
    └─ 必然: ✗ 回调
```

### 2. 绘制调用流程图

**示例: 借贷协议**

```
User calls: borrow(token, 100)
│
├─ Check: collateral >= required
│
├─ External Call 1: oracle.getPrice(token)
│   │
│   └─  Oracle可能回调
│       └─ Attacker.oracleCallback()
│           └─ ✗ lending.withdrawCollateral() (重入！)
│
├─ Update: debt[user] += 100
│
└─ External Call 2: token.transfer(user, 100)
    │
    └─  如果是ERC777
        └─ Attacker.tokensReceived()
            └─ ✗ lending.borrow() (重入！)
```

### 3. 建立威胁模型

**假设所有外部合约都可能恶意:**

| 外部合约类型 | 可信度 | 可能的攻击 |
|------------|--------|----------|
| Chainlink Oracle | 高 | 几乎不会，但要防前端运行 |
| Uniswap V2/V3 | 高 | 闪电贷+价格操纵 |
| 自定义Oracle | 低 | 回调重入 |
| Router/Aggregator | 中 | 可能被控制 |
| ERC777 Token | 低 | 必然有回调 |
| 用户合约 | 低 | 任何恶意行为 |

**问题清单:**

- [ ] 这个外部调用是否必要？
- [ ] 可以改成view/pure吗？
- [ ] 调用前是否完成了所有状态更新？
- [ ] 如果外部合约恶意，最坏情况是什么？
- [ ] 有没有ReentrancyGuard保护？
- [ ] 调用深度是否有限制？

### 4. 使用AST工具检测

**工具应该检查:**

```python
# 伪代码
def analyze_cross_contract_reentrancy(contract_ast):
    vulnerabilities = []
    
    for function in contract.functions:
        # 找到所有外部调用
        external_calls = find_external_calls(function)
        
        for call in external_calls:
            # 检查调用后是否有状态更新
            if has_state_update_after_call(function, call):
                vulnerabilities.append({
                    'type': 'state_update_after_external_call',
                    'function': function.name,
                    'call': call,
                    'severity': 'HIGH'
                })
            
            # 检查被调用合约的类型
            target = get_call_target(call)
            if is_external_dependency(target):
                # 警告：依赖外部合约
                vulnerabilities.append({
                    'type': 'external_dependency',
                    'function': function.name,
                    'target': target,
                    'severity': 'MEDIUM'
                })
            
            # 特别检查已知危险接口
            if is_erc777(target):
                vulnerabilities.append({
                    'type': 'erc777_callback_risk',
                    'function': function.name,
                    'severity': 'HIGH'
                })
    
    return vulnerabilities
```

**自动生成测试用例:**

```python
def generate_reentrancy_tests(vulnerabilities):
    for vuln in vulnerabilities:
        # 生成恶意合约
        malicious_contract = create_malicious_contract(vuln)
        
        # 生成测试
        test_case = f"""
        function test_{vuln.function}_reentrancy() public {{
            MaliciousContract attacker = new MaliciousContract();
            
            // Setup attack
            attacker.setTarget(address(protocol));
            
            // Execute
            vm.expectRevert("No reentrancy");
            attacker.attack();
        }}
        """
        
        write_test(test_case)
```

## 防御策略总结

### 层次化防御（推荐）

```solidity
// Layer 1: 全局ReentrancyGuard
contract Protocol is ReentrancyGuard {
    
    // Layer 2: CEI模式
    function withdraw(uint amount) external nonReentrant {
        // Checks
        require(balance[msg.sender] >= amount);
        
        // Effects - 先更新
        balance[msg.sender] -= amount;
        
        // Interactions - 后调用
        externalContract.call(...);
    }
    
    // Layer 3: 限制外部合约
    mapping(address => bool) public trustedContracts;
    
    modifier onlyTrusted(address target) {
        require(trustedContracts[target], "Untrusted");
        _;
    }
    
    function callExternal(address target) 
        external 
        onlyTrusted(target) 
        nonReentrant 
    {
        // ...
    }
}
```

### 不同场景的最佳实践

**Router/Aggregator:**
```solidity
// 使用白名单
mapping(address => bool) public approvedRouters;

function swap(address router, ...) external {
    require(approvedRouters[router], "Router not approved");
    // ...
}

// 限制回调
interface IRouter {
    function swap(...) external returns (bytes memory);
    // 不允许Router调用回我们的其他函数
}
```

**Price Oracle:**
```solidity
// 使用view函数
interface IPriceOracle {
    function getPrice(address token) 
        external 
        view  // ← 确保只读
        returns (uint256);
}

// 或者缓存价格
uint256 public lastPriceUpdate;
mapping(address => uint256) public prices;

function updatePrice(address token) external {
    prices[token] = oracle.getPrice(token);
    lastPriceUpdate = block.timestamp;
}
```

**ERC777代币:**
```solidity
// 方案1: 完全禁止
function deposit(address token, uint amount) external {
    require(!_isERC777(token), "ERC777 not supported");
    // ...
}

// 方案2: 严格CEI
function withdraw(address token, uint amount) external nonReentrant {
    balance[msg.sender][token] -= amount;  // 先更新
    IERC20(token).transfer(msg.sender, amount);  // 后转账
}

// 方案3: 检查接口
function _isERC777(address token) internal view returns (bool) {
    try IERC165(token).supportsInterface(0xac7fbab5) returns (bool result) {
        return result;  // 0xac7fbab5 = ERC777的interface ID
    } catch {
        return false;
    }
}
```

## 真实案例深度分析

### Cream Finance (2021.08) - $130M

**攻击链:**

```
1. 闪电贷借入18,000 ETH
   ↓
2. 存入Cream作为抵押品
   ↓
3. 借出AMP代币（类ERC777）
   ↓
4. AMP.transfer触发tokensReceived回调
   ↓
5. 在回调中重入Cream.borrow()
   ↓
6. 因为抵押品记录还未更新，可以继续借
   ↓
7. 重复步骤3-6多次
   ↓
8. 获得远超抵押品价值的借款
   ↓
9. 还闪电贷，获利离场
```

**关键代码（简化）:**

```solidity
// Cream的borrow函数
function borrow(address token, uint amount) external {
    // 检查抵押率
    uint collateralValue = getAccountCollateral(msg.sender);
    uint borrowValue = getBorrowValue(msg.sender);
    require(collateralValue * 100 / borrowValue >= 150);
    
    // 更新借款
    borrowed[msg.sender][token] += amount;
    
    // 转账（触发AMP的回调）
    IERC20(token).transfer(msg.sender, amount);
    // 在这里被重入了！
}
```

**为什么成功？**

1. AMP是类ERC777代币，有transfer回调
2. Cream的borrow没有ReentrancyGuard
3. 抵押品价值计算使用的是旧状态
4. 可以在一个交易中多次重入

**如何防御：**

```solidity
// 修复版本
function borrow(address token, uint amount) 
    external 
    nonReentrant  // ← 添加重入保护
{
    // 先更新状态
    borrowed[msg.sender][token] += amount;
    
    // 再检查（使用更新后的状态）
    uint collateralValue = getAccountCollateral(msg.sender);
    uint borrowValue = getBorrowValue(msg.sender);
    require(collateralValue * 100 / borrowValue >= 150);
    
    // 最后转账
    IERC20(token).transfer(msg.sender, amount);
}
```

### Grim Finance (2021.12) - $30M

**特点:** 通过策略合约的复杂调用链重入

**攻击链:**

```
Vault
  ├─ deposit()
  │   └─ Strategy.deposit()
  │       └─ ExternalFarm.deposit()
  │           └─ RewardToken.transfer()
  │               └─ Attacker.tokensReceived()
  │                   └─ ✗ Vault.withdraw() (重入！)
```

**教训:**

1. 不仅要保护Vault，也要保护Strategy
2. 多层调用链中的任何一层都可能触发重入
3. 需要端到端的安全分析
