# 跨函数重入攻击 - 深度学习指南

## 快速开始

```bash
# 1. 运行DEX攻击示例
forge test --match-contract CrossFunctionReentrancyTest --match-test testCrossFunctionReentrancy -vvvv

# 2. 查看攻击机制详解
forge test --match-test testAttackMechanism -vvvv

# 3. 运行借贷协议攻击
forge test --match-contract LendingReentrancyTest -vvvv
```

## 核心概念

### 跨函数重入 vs 单函数重入

```
单函数重入：
withdraw() 
  → 发送ETH 
  → receive() 
  → withdraw() (再次调用同一函数)

跨函数重入：
withdraw() 
  → 发送ETH 
  → receive() 
  → transfer() (调用不同函数！)
```

### 为什么更危险？

1. **隐蔽性更强**
   - `transfer()` 函数本身可能完全"安全"
   - 遵循了CEI模式，看起来没问题
   - 但与`withdraw()`组合时就有问题

2. **审计盲区**
   - 开发者往往只检查单个函数
   - 忽略了函数间的交互和共享状态
   - "安全"的函数可能被"不安全"的函数利用

3. **更难检测**
   - 静态分析工具可能报告"通过"
   - 需要理解整个合约的状态机
   - AST分析工具在这里很**有用**

## 攻击场景详解

### 场景1: DEX攻击（余额操纵）

**初始状态:**
```
Attacker balance in DEX: 5 ETH
Accomplice balance in DEX: 0 ETH
```

**攻击流程:**

**Step 1: 调用 withdraw(5 ETH)**
```solidity
function withdraw(uint256 _amount) external {
    require(balances[msg.sender] >= _amount);  //  5 >= 5
    
    // 发送5 ETH → 触发attacker.receive()
    (bool success, ) = msg.sender.call{value: _amount}("");
    
    // 暂停在这里！还未执行下面的代码
    balances[msg.sender] -= _amount;  // 还没执行！
}
```

**Step 2: 在 receive() 中重入 transfer()**
```solidity
receive() external payable {
    // 此时 balances[attacker] 仍然是 5 ETH！
    console.log(balances[address(this)]); // 输出: 5 ETH
    
    // 调用transfer把这5 ETH"转"给共犯
    dex.transfer(accomplice, 5 ether);
}
```

**Step 3: transfer() 执行**
```solidity
function transfer(address _to, uint256 _amount) external {
    require(balances[msg.sender] >= _amount);  //  5 >= 5 (仍然通过！)
    
    // 状态更新
    balances[msg.sender] -= _amount;      // attacker: 5 - 5 = 0
    balances[_to] += _amount;             // accomplice: 0 + 5 = 5
}
```

**Step 4: 回到 withdraw()**
```solidity
// transfer()完成，继续执行withdraw()
balances[msg.sender] -= _amount;  // 0 - 5 = -5 (下溢！)

// 在Solidity 0.8+会revert
// 但在0.8以前版本会下溢成一个巨大的数字
```

**最终结果:**
```
Attacker: 拿到5 ETH现金 + 0 ETH余额
Accomplice: 0 ETH现金 + 5 ETH余额

实际影响：
- 如果是Solidity 0.8+：withdraw会revert，但transfer已经完成
- 如果是旧版本：更严重，可能导致整数下溢

关键是：即使withdraw最后revert了，
transfer()中的状态修改已经永久生效！
```

### 场景2: 借贷协议攻击（抵押率绕过）

**初始状态:**
```
Attacker deposit: 10 ETH
Attacker borrowed: 0 ETH
Collateral ratio: 150%
Max borrow: 10 / 1.5 = 6.66 ETH
```

**攻击流程:**

**Step 1: 调用 withdrawCollateral(10 ETH)**
```solidity
function withdrawCollateral(uint256 _amount) external {
    require(deposits[msg.sender] >= _amount);  //  10 >= 10
    
    // 检查抵押率（使用旧的deposits值）
    uint256 requiredCollateral = (borrowed[msg.sender] * 150) / 100;
    // borrowed = 0, 所以 requiredCollateral = 0
    require(deposits[msg.sender] - _amount >= requiredCollateral);  // 通过
    
    // 发送10 ETH → 触发receive()
    (bool success, ) = msg.sender.call{value: _amount}("");
    
    // 暂停，还未更新deposits
    deposits[msg.sender] -= _amount;  //  还没执行
}
```

**Step 2: 在 receive() 中重入 borrow()**
```solidity
receive() external payable {
    // 此时 deposits[attacker] 仍然是 10 ETH！
    uint256 maxBorrow = (deposits[address(this)] * 100) / 150;
    // maxBorrow = (10 * 100) / 150 = 6.66 ETH
    
    // 可以借款！
    lending.borrow(6.66 ether);
}
```

**Step 3: borrow() 执行**
```solidity
function borrow(uint256 _amount) external {
    uint256 maxBorrow = (deposits[msg.sender] * 100) / 150;
    // 仍然是 (10 * 100) / 150 = 6.66 ETH
    
    require(borrowed[msg.sender] + _amount <= maxBorrow);  //  通过
    
    borrowed[msg.sender] += _amount;  // borrowed = 6.66 ETH
    
    // 发送6.66 ETH
    (bool success, ) = msg.sender.call{value: _amount}("");
}
```

**最终结果:**
```
Attacker得到：
- 10 ETH (提取的抵押品)
- 6.66 ETH (借款)
- 总计: 16.66 ETH

Attacker在协议中的记录：
- deposits: 0 ETH (最终被更新)
- borrowed: 6.66 ETH

问题：没有抵押品却有债务！
协议遭受坏账：6.66 ETH
```

## 真实案例分析

### Lendf.me (2020.04) - $25M

**漏洞类型:** ERC777跨函数重入

**攻击流程:**
```solidity
// Lendf.me的漏洞代码（简化）
function supply(address token, uint amount) {
    // 先转入代币
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    
    // 后更新余额
    balances[msg.sender] += amount;
}

function withdraw(uint amount) {
    require(balances[msg.sender] >= amount);
    
    // 先发送代币（如果是ERC777会触发回调）
    IERC20(token).transfer(msg.sender, amount);
    
    // 后更新余额
    balances[msg.sender] -= amount;
}
```

**攻击者的操作:**
1. supply() ERC777代币
2. withdraw() 触发tokensReceived回调
3. 在回调中再次supply()相同的代币
4. 余额被重复计入

**教训:**
- 注意ERC777的回调机制
- 所有涉及余额的函数都要保护
- 不要假设"只是转账"是安全的

### Cream Finance (2021.08) - $130M

**漏洞类型:** 复杂的跨函数重入 + 价格操纵

**攻击链:**
```
1. 闪电贷借大量ETH
2. deposit ETH到Cream
3. borrow AMP代币
4. 在AMP转账回调中重入Cream
5. 再次borrow（利用未更新的抵押品价值）
6. 重复步骤4-5多次
7. 获得远超抵押品价值的借款
```

**关键点:**
- AMP是类似ERC777的代币，有transfer回调
- 多个函数组合攻击
- 利用了价格oracle的延迟更新

### bZx (2020.02) - $8M

**攻击特点:**
- 跨协议重入（bZx → Uniswap → bZx）
- 利用了价格更新的时间窗口
- 闪电贷 + 重入组合

## 审计检查清单

### 识别潜在漏洞

**1. 找出所有外部调用点**
```bash
# 使用grep查找
grep -n "\.call" contract.sol
grep -n "\.transfer" contract.sol
grep -n "\.send" contract.sol
grep -n "\.delegatecall" contract.sol
```

**2. 识别共享状态**
```solidity
// 问自己：
// - 哪些函数读写相同的mapping/variable？
// - 状态更新顺序是否一致？
// - 是否有全局重入保护？

mapping(address => uint256) public balances;  // 共享状态

function withdraw() { }      // 修改balances
function transfer() { }      // 也修改balances
function borrow() { }        // 读取balances
```

**3. 绘制调用流程图**
```
withdraw()
  ├─ require(balances[user] >= amount)
  ├─ call(user, amount)   外部调用
  │   └─ 可能触发重入
  │       ├─ transfer() 
  │       ├─ borrow() 
  │       └─ approve() 
  └─ balances[user] -= amount
```

**4. 检查CEI模式**
```solidity
// 危险模式
function withdraw() {
    require(check);
    externalCall();    // 外部调用在中间
    stateUpdate();     // 状态更新在后
}

// 安全模式
function withdraw() {
    require(check);
    stateUpdate();     // 状态更新在前
    externalCall();    // 外部调用在后
}
```

### 审计Checklist

- [ ] 是否有全局ReentrancyGuard？
- [ ] 所有修改共享状态的函数都加了nonReentrant？
- [ ] 包括那些"看起来安全"的函数吗？
- [ ] 是否使用ERC777/ERC721等带回调的标准？
- [ ] CEI模式是否在所有函数中一致？
- [ ] 检查逻辑是使用更新前还是更新后的状态？
- [ ] 是否有跨合约调用可能触发重入？
- [ ] 是否依赖外部合约的返回值做关键决策？

## 防御策略对比

### 方案1: 全局ReentrancyGuard

```solidity
contract SecureProtocol is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    // ✅ 所有可能被重入的函数都加保护
    function withdraw(uint256 amount) external nonReentrant {
        // ...
    }
    
    function transfer(address to, uint256 amount) external nonReentrant {
        // ...
    }
    
    function borrow(uint256 amount) external nonReentrant {
        // ...
    }
}
```

**优点:**
- 简单直接
- 保护整个合约
- 防止跨函数重入

**缺点:**
- 额外gas成本
- 可能影响可组合性

### 方案2: 严格CEI模式

```solidity
function withdraw(uint256 amount) external {
    // 1. Checks
    require(balances[msg.sender] >= amount);
    
    // 2. Effects - 完全更新状态
    balances[msg.sender] -= amount;
    
    // 3. Interactions - 最后外部调用
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}

function borrow(uint256 amount) external {
    require(deposits[msg.sender] * 100 / 150 >= borrowed[msg.sender] + amount);
    
    // 先更新borrowed
    borrowed[msg.sender] += amount;
    
    // 后外部调用
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

**优点:**
- 零额外gas成本
- 符合最佳实践
- 代码更清晰

**缺点:**
- 需要重构现有代码
- 所有函数都要遵守
- 复杂逻辑难以保证

### 方案3: 组合防御（大型项目推荐）

```solidity
contract SecureProtocol is ReentrancyGuard {
    // CEI + ReentrancyGuard 双重保护
    
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount);
        
        // 遵循CEI
        balances[msg.sender] -= amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}
```

## 测试策略

### 1. 单元测试

```solidity
function testCrossFunctionReentrancy() public {
    // 部署攻击合约
    attacker = new Attacker();
    
    // 记录初始状态
    uint256 balanceBefore = protocol.balances(address(attacker));
    
    // 执行攻击
    attacker.attack();
    
    // 验证状态一致性
    assertEq(
        protocol.balances(address(attacker)),
        balanceBefore,
        "Balance should not change through reentrancy"
    );
}
```

### 2. 不变量测试

```solidity
// 使用Foundry的invariant testing
contract ProtocolInvariantTest is Test {
    Protocol protocol;
    
    function invariant_totalBalanceConsistency() public {
        // 不变量：账面余额之和 <= 实际ETH余额
        uint256 accountedBalance = 0;
        for (uint i = 0; i < users.length; i++) {
            accountedBalance += protocol.balances(users[i]);
        }
        
        assertLe(accountedBalance, address(protocol).balance);
    }
    
    function invariant_collateralRatio() public {
        // 不变量：所有借款人的抵押率 >= 150%
        for (uint i = 0; i < users.length; i++) {
            if (protocol.borrowed(users[i]) > 0) {
                uint256 collateral = protocol.deposits(users[i]);
                uint256 debt = protocol.borrowed(users[i]);
                assertGe(collateral * 100, debt * 150);
            }
        }
    }
}
```

### 3. 模糊测试

```solidity
function testFuzz_noReentrancy(
    uint256 amount1,
    uint256 amount2,
    address user
) public {
    // 约束输入
    vm.assume(amount1 > 0 && amount1 < 100 ether);
    vm.assume(amount2 > 0 && amount2 < 100 ether);
    vm.assume(user != address(0));
    
    // 测试各种组合
    // ...
}
```

## 结合AST工具

### 自动检测跨函数重入

```python
# 伪代码示例
def detect_cross_function_reentrancy(contract_ast):
    # 1. 识别共享状态
    shared_states = find_shared_state_variables(contract_ast)
    
    # 2. 找出所有外部调用
    external_calls = find_external_calls(contract_ast)
    
    # 3. 检查调用顺序
    for call in external_calls:
        function = call.parent_function
        
        # 外部调用后是否有状态更新？
        if has_state_update_after_call(function, call, shared_states):
            report_vulnerability(function, call)
        
        # 其他函数是否操作相同状态？
        for other_func in contract.functions:
            if other_func != function:
                if modifies_shared_state(other_func, shared_states):
                    report_cross_function_risk(function, other_func)
```

