## 快速开始

```bash
# 1. 未初始化代理攻击（最常见）
forge test --match-test testUninitializedProxyAttack -vvvv

# 2. 存储槽冲突
forge test --match-test testStorageCollision -vvvv

# 3. Selfdestruct劫持
forge test --match-test testSelfDestructAttack -vvvv

# 4. Parity钱包攻击复现
forge test --match-test testParityAttack -vvvv
```

## 核心概念

### Delegatecall vs Call

```solidity
// Call: 在目标合约的上下文执行
A.call(B)
├─ 执行B的代码
├─ msg.sender = A
├─ 使用B的storage
└─ 使用B的balance

// Delegatecall: 在调用者的上下文执行
A.delegatecall(B)
├─ 执行B的代码
├─ msg.sender = 原始调用者
├─ 使用A的storage ← 关键！
└─ 使用A的balance
```

**关键理解：**
```solidity
contract Proxy {
    address public owner;  // slot 0
    
    function execute(address target) external {
        target.delegatecall(...);
        // 如果target的代码修改了slot 0
        // 那么Proxy的owner会被修改！
    }
}
```

### 存储槽（Storage Slot）

**Solidity存储布局：**
```solidity
contract Example {
    uint256 a;      // slot 0
    address b;      // slot 1
    bool c;         // slot 2
    mapping(address => uint) d;  // slot 3（实际数据在keccak256计算的位置）
}
```

**代理模式的危险：**
```
Proxy:               Logic:
slot 0: impl    vs   slot 0: owner
slot 1: owner   vs   slot 1: data

通过delegatecall，Logic修改slot 0（它的owner）
实际修改的是Proxy的slot 0（impl）
→ Implementation被劫持！
```

## 五大攻击场景

### 场景1: 未初始化代理（最常见）

**漏洞代码：**
```solidity
contract VulnerableProxy {
    address public implementation;
    address public owner;
    
    // 没有在constructor中初始化
    constructor() {}
    
    // 没有权限保护
    function setImplementation(address _impl) external {
        implementation = _impl;
    }
}
```

**攻击流程：**
```
1. 部署恶意Logic合约
   function initialize() external {
       owner = msg.sender;  // 设置攻击者为owner
   }

2. 调用proxy.setImplementation(maliciousLogic)

3. 通过proxy调用initialize()
   → delegatecall执行，在proxy上下文
   → proxy.owner = attacker

4. 现在攻击者是proxy的owner
   → 可以drain所有资金
```

**防御：**
```solidity
contract SecureProxy {
    address public immutable implementation;  // 不可变
    bool private initialized;
    
    constructor(address _impl) {
        implementation = _impl;
    }
    
    function initialize(bytes memory data) external {
        require(!initialized, "Already initialized");
        initialized = true;
        
        (bool success, ) = implementation.delegatecall(data);
        require(success);
    }
}
```

### 场景2: 存储槽冲突（技术性强）

**问题根源：**
```solidity
// Proxy的布局
contract Proxy {
    address implementation;  // slot 0
    address owner;          // slot 1
}

// Logic的布局（不匹配！）
contract Logic {
    address owner;          // slot 0 ← 冲突！
    uint256 data;          // slot 1
}
```

**攻击流程：**
```solidity
// 通过proxy调用logic.setOwner()
proxy.delegatecall(logic.setOwner(attackerAddress))

在proxy的上下文执行：
slot 0 = attackerAddress  ← 这是proxy的implementation！

结果：
proxy.implementation = attackerAddress
```

**真实案例思路：**
```
1. 发现存储布局不匹配
2. 找到修改slot 0的函数
3. 设置为恶意合约地址
4. 后续所有调用都执行恶意代码
```

**防御 - EIP-1967标准：**
```solidity
contract StandardProxy {
    // 使用特殊槽位，避免冲突
    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)
    bytes32 private constant IMPL_SLOT = 
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    
    function _setImpl(address newImpl) private {
        assembly {
            sstore(IMPL_SLOT, newImpl)
        }
    }
    
    function _getImpl() private view returns (address impl) {
        assembly {
            impl := sload(IMPL_SLOT)
        }
    }
}
```

### 场景3: Selfdestruct劫持

**危险代码：**
```solidity
contract MultiSig {
    function execute(
        address target,
        bytes memory data,
        bool useDelegatecall
    ) external onlyOwner {
        if (useDelegatecall) {
            target.delegatecall(data);  // 非常危险
        }
    }
}
```

**攻击：**
```solidity
contract Destroyer {
    function destroy() external {
        selfdestruct(payable(msg.sender));
    }
}

// 攻击者调用
multisig.execute(
    address(destroyer),
    abi.encodeWithSignature("destroy()"),
    true  // useDelegatecall
);

// 结果：multisig合约被销毁！
```

**为什么危险？**
- Selfdestruct在调用者的上下文执行
- 销毁的是调用者（multisig），不是目标（destroyer）
- 合约代码消失，资金永久锁定或发送给攻击者

**防御：**
```solidity
// 方案1: 完全禁止delegatecall
function execute(address target, bytes memory data) external {
    target.call(data);  // 只允许call
}

// 方案2: 白名单
mapping(address => bool) public trustedLibraries;

function execute(address target, bool delegate) external {
    if (delegate) {
        require(trustedLibraries[target], "Not trusted");
    }
    // ...
}
```

### 场景4: Library劫持

**可升级Library模式：**
```solidity
contract UsingLibrary {
    address public libraryAddress;
    
    function setLibrary(address _lib) external onlyOwner {
        libraryAddress = _lib;
    }
    
    function compute(uint a, uint b) external returns (uint) {
        bytes memory data = abi.encodeWithSignature("add(uint256,uint256)", a, b);
        (bool success, bytes memory result) = libraryAddress.delegatecall(data);
        require(success);
        return abi.decode(result, (uint));
    }
}
```

**攻击：**
```solidity
// 恶意"Library"
contract MaliciousLib {
    address libraryAddress;  // slot 0 - 匹配主合约
    address owner;          // slot 1
    
    function add(uint a, uint b) external returns (uint) {
        // ✗ 不是真的做加法，而是修改owner
        owner = address(uint160(a));
        return b;
    }
}

// 如果攻击者能调用setLibrary
victim.setLibrary(address(maliciousLib));

// 然后调用compute
victim.compute(uint(uint160(attacker)), 0);
// 在victim上下文执行，victim.owner = attacker
```

### 场景5: Parity多签钱包（历史重大事件）

**第一次攻击 (2017.07) - $30M被盗**

```solidity
// Parity Wallet Library（简化）
contract WalletLibrary {
    address public owner;
    
    // 初始化函数没有保护
    function initWallet(address _owner) external {
        require(owner == address(0));
        owner = _owner;
    }
    
    function execute(address to, uint value) external {
        require(msg.sender == owner);
        to.call{value: value}("");
    }
}

contract Wallet {
    address library;
    
    fallback() external payable {
        library.delegatecall(msg.data);
    }
}
```

**攻击者做了什么：**
```
1. 调用wallet.initWallet(attackerAddress)
   → 通过delegatecall在wallet上下文执行
   → wallet.owner = attacker

2. 调用wallet.execute(attacker, all_balance)
   → 转走所有ETH

3. 重复对多个钱包
   → 总共$30M被盗
```

**第二次事件 (2017.11) - $150M永久锁定**

**关键问题：Library本身也是合约**
```solidity
// WalletLibrary不仅被delegatecall使用
// 它本身也是一个部署在链上的合约
// 可以被直接调用！

// devops199（可能不是恶意）做了：
library.initWallet(devops199);
// 现在library本身有了owner

library.kill(devops199);
// library被销毁！

// 结果：
// - Library的代码消失
// - 所有使用这个library的wallet无法工作
// - 584个钱包，$150M永久锁定
// - 包括Polkadot ICO的资金
```

**为什么如此严重？**
```
影响范围：
├─ Polkadot: 306,000 ETH (~$90M)
├─ Edgeless Casino: 26,000 ETH
├─ Swarm City: 44,000 ETH
└─ 其他钱包: ~100,000 ETH

总计: ~513,000 ETH (当时价值~$150M)
```

**修复方案讨论：**
```
社区提议：
1. 硬分叉恢复资金 → 被否决（不想重复The DAO）
2. 账户抽象EIP → 太复杂，未实施
3. 让资金永久锁定 → 最终结果

教训：
- Library不应该有可修改的状态
- Library不应该能被直接调用
- 初始化必须有保护
- Selfdestruct极其危险
```

## 真实案例对比

| 项目 | 时间 | 损失 | 漏洞类型 | 根本原因 |
|------|------|------|----------|---------|
| Parity (第1次) | 2017.07 | $30M被盗 | 未初始化 | initWallet无保护 |
| Parity (第2次) | 2017.11 | $150M锁定 | Selfdestruct | Library被销毁 |
| Akutars | 2022.04 | $34M锁定 | 逻辑错误 | 无法退款 |

## 审计完整检查表

### 第1步：识别代理模式

```markdown
- [ ] 这是代理合约吗？
- [ ] 使用什么模式？（Transparent/UUPS/Beacon/Diamond）
- [ ] Implementation在哪里存储？
- [ ] 谁可以修改implementation？
```

### 第2步：初始化检查

```markdown
- [ ] 是否有初始化函数？
- [ ] 初始化是否有访问控制？
- [ ] 可以重复初始化吗？
- [ ] Constructor vs initialize的区别？
```

**关键点：**
```solidity
// 错误：Constructor在proxy模式无效
contract Logic {
    address public owner;
    
    constructor() {
        owner = msg.sender;  // 只在Logic部署时执行，不在proxy中
    }
}

// 正确：使用initialize
contract Logic {
    address public owner;
    bool private initialized;
    
    function initialize() external {
        require(!initialized);
        initialized = true;
        owner = msg.sender;
    }
}
```

### 第3步：存储布局检查

```markdown
- [ ] Proxy和Logic存储布局是否匹配？
- [ ] 是否使用EIP-1967标准槽位？
- [ ] 升级时是否验证兼容性？
- [ ] 是否有存储碰撞风险？
```

**工具辅助：**
```bash
# 使用hardhat-storage-layout
npx hardhat storage-layout

# 对比Proxy和Logic的布局
diff proxy_storage.json logic_storage.json
```

### 第4步：Delegatecall使用检查

```markdown
- [ ] 哪些地方使用了delegatecall？
- [ ] 目标地址是否可控？
- [ ] 是否有白名单？
- [ ] 是否允许delegatecall到任意地址？
```

**危险模式识别：**
```solidity
// 极度危险
function execute(address target, bytes data) external {
    target.delegatecall(data);  // 完全不受控
}

// 有风险
function executeLib(address lib, bytes data) external onlyOwner {
    lib.delegatecall(data);  // owner可能被攻击
}

// 相对安全
function execute(bytes data) external {
    immutableImpl.delegatecall(data);  // 地址固定
}
```

### 第5步：危险操作检查

```markdown
- [ ] Logic合约是否包含selfdestruct？
- [ ] 是否可以通过delegatecall触发？
- [ ] 是否有其他状态修改操作？
- [ ] 是否有权限提升风险？
```

### 第6步：升级机制检查

```markdown
- [ ] 谁可以升级？
- [ ] 升级是否有时间锁？
- [ ] 是否需要多签？
- [ ] 是否有升级提案机制？
- [ ] 用户是否有退出窗口？
```

## BlockSec面试常见问题

### Q1: Delegatecall和Call的区别？

**标准答案：**
```
Call:
- 在目标合约上下文执行
- msg.sender是调用者
- 修改目标合约的存储
- 使用目标合约的余额

Delegatecall:
- 在调用者上下文执行
- msg.sender保持不变
- 修改调用者的存储
- 使用调用者的余额

用途：
- Call: 正常的合约交互
- Delegatecall: 代理模式、Library、可升级合约
```

### Q2: Parity被攻击两次，说说原理

**第一次（必答）：**
```
漏洞：initWallet没有访问控制
攻击：
1. 攻击者调用wallet.initWallet(attacker)
2. 通过delegatecall，设置wallet.owner = attacker
3. 调用execute转走资金
影响：$30M被盗
修复：添加初始化保护
```

**第二次（加分）：**
```
漏洞：Library可以被直接调用并销毁
攻击：
1. Library本身是合约，可以直接调用
2. 调用library.initWallet(attacker)获得控制
3. 调用library.kill()销毁library
4. 所有依赖library的wallet失效
影响：$150M永久锁定，584个钱包
教训：Library不应有状态，不应能被直接调用
```

### Q3: 如何安全实现可升级合约？

**完整答案：**
```
1. 使用标准模式（OpenZeppelin）
   - TransparentUpgradeableProxy
   - UUPS模式
   - Beacon Proxy

2. 存储安全
   - EIP-1967标准槽位
   - 存储布局验证
   - 使用storage gap

3. 访问控制
   - 多签控制升级
   - 时间锁延迟
   - 提案+投票机制

4. 初始化
   - 使用initialize而非constructor
   - 防止重复初始化
   - 初始化检查

5. 测试
   - 升级前后状态验证
   - 存储布局兼容性测试
   - 审计和形式化验证
```

### Q4: 给你一个代理合约审计，你会看什么？

**系统化回答：**
```
1. 架构分析
   - 代理模式类型
   - 组件关系图
   - 权限层次

2. 初始化
   - 是否正确初始化
   - 能否被重复调用
   - Constructor vs initialize

3. 存储布局
   - Proxy和Logic是否匹配
   - 是否使用标准槽位
   - 升级兼容性

4. 访问控制
   - 谁可以升级
   - 时间锁/多签
   - Admin vs User分离

5. Delegatecall
   - 所有delegatecall调用点
   - 目标地址可控性
   - 潜在的存储覆盖

6. 特殊操作
   - Selfdestruct风险
   - 状态修改函数
   - 权限提升可能

7. 测试验证
   - 升级场景测试
   - 恶意logic测试
   - 边界条件
```

## 防御最佳实践

### 方案1: 使用OpenZeppelin（推荐）

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract MyLogic is Initializable, OwnableUpgradeable {
    uint256 public value;
    
    function initialize() public initializer {
        __Ownable_init();
    }
    
    function setValue(uint256 _value) external onlyOwner {
        value = _value;
    }
}

// 部署
TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(
    address(logic),
    proxyAdmin,
    abi.encodeWithSignature("initialize()")
);
```

### 方案2: UUPS模式

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract MyLogic is UUPSUpgradeable, OwnableUpgradeable {
    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyOwner 
    {}
}
```

**优点：**
- Gas更便宜（升级逻辑在logic中）
- 更灵活（可以自定义升级逻辑）

**缺点：**
- Logic更复杂
- 错误可能导致无法升级

### 方案3: 完全不可变

```solidity
// 如果不需要升级，使用immutable最安全
contract Proxy {
    address public immutable implementation;
    
    constructor(address _impl) {
        implementation = _impl;
    }
    
    fallback() external payable {
        address impl = implementation;
        // ... delegatecall logic
    }
}
```

## 下一步学习

完成Delegatecall hijacking后，你应该：

理解代理模式的安全要点
能识别delegatecall相关漏洞
了解Parity等历史案例
掌握审计代理合约的方法
